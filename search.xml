<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[VBoxManage使用]]></title>
    <url>%2F2019%2F11%2F27%2FVBoxManage%2F</url>
    <content type="text"><![CDATA[VBoxManage 命令行管理VirtualBox 前言本文要操作的虚拟机信息如下： 名称: UbuntuRDHome 镜像名称: ubuntu-16.04.3-server-amd64.iso 网络连接: 桥接 主机环境： $ uname -a命令输出： Linux UbuntuServer 4.10.0-37-generic #41-Ubuntu SMP Fri Oct 6 20:20:37 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux $ lsb_release -a命令输出： No LSB modules are available. Distributor ID: Ubuntu Description: Ubuntu 17.04 Release: 17.04 Codename: zesty $ ifconfig命令输出： enp5s0f0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 172.16.8.3 netmask 255.255.255.0 broadcast 172.16.8.255 inet6 fe80::dad3:85ff:fee3:8a56 prefixlen 64 scopeid 0x20&lt;link&gt; ether d8:d3:85:e3:8a:56 txqueuelen 1000 (Ethernet) RX packets 12193671 bytes 5948053357 (5.9 GB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 19703213 bytes 21537731944 (21.5 GB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 device memory 0xc0400000-c041ffff lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 12358 bytes 750596 (750.5 KB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 12358 bytes 750596 (750.5 KB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0创建UbuntuRDHome虚拟机创建虚拟机（同时注册） VBoxManage createvm --name UbuntuRDHome --register 注册虚拟机 VBoxManage registervm &lt;Absolute Full Path&gt;/UbuntuRDHome.vbox 仅注销虚拟机 VBoxManage unregistervm UbuntuRDHome 删除虚拟机（！！！会删除所有虚拟硬盘，谨慎操作！！！） VBoxManage unregistervm --delete UbuntuRDHome设置系统类型Ubuntu_64 VBoxManage modifyvm UbuntuRDHome –ostype Ubuntu_64 设置内存大小4G VBoxManage modifyvm UbuntuRDHome –memory 4096 建立虚拟磁盘：系统盘100G VBoxManage createmedium –filename UbuntuRDHome_HDD_SYS_100G.vdi –size 100000 建立虚拟磁盘：HOME盘100G VBoxManage createmedium –filename UbuntuRDHome_HDD_HOME_100G.vdi –size 100000 创建存储控制器IDE、SATA VBoxManage storagectl UbuntuRDHome --name IDE --add ide --controller PIIX4 --bootable on VBoxManage storagectl UbuntuRDHome --name SATA --add sata --controller IntelAhci --bootable on 移除控制器： VBoxManage storagectl UbuntuRDHome --name IDE --remove VBoxManage storagectl UbuntuRDHome --name SATA --remove关联虚拟机磁盘 VBoxManage storageattach UbuntuRDHome --storagectl SATA --port 0 --device 0 --type hdd --medium UbuntuRDHome_HDD_SYS_100G.vdi VBoxManage storageattach UbuntuRDHome --storagectl SATA --port 1 --device 0 --type hdd --medium UbuntuRDHome_HDD_HOME_100G.vdi 解除关联： VBoxManage storageattach UbuntuRDHome --storagectl SATA --port 0 --device 0 --type hdd --medium none VBoxManage storageattach UbuntuRDHome --storagectl SATA --port 1 --device 0 --type hdd --medium none关联镜像文件 VBoxManage storageattach UbuntuRDHome --storagectl IDE --port 0 --device 0 --type dvddrive --medium ubuntu-16.04.3-server-amd64.iso VBoxManage storageattach UbuntuRDHome --storagectl IDE --port 1 --device 0 --type dvddrive --medium VBoxGuestAdditions_5.1.22.iso 解除关联： VBoxManage storageattach UbuntuRDHome --storagectl IDE --port 0 --device 0 --type dvddrive --medium none VBoxManage storageattach UbuntuRDHome --storagectl IDE --port 1 --device 0 --type dvddrive --medium none设置网络为桥接（nictype和bridgeadapter要根据主机的实际情况选择） VBoxManage modifyvm UbuntuRDHome –nic1 bridged –nictype1 82545EM –cableconnected1 on –bridgeadapter1 enp5s0f0 设置远程桌面（可以使用VNC通过5540端口访问虚拟机桌面） VBoxManage modifyvm UbuntuRDHome –vrdeport 5540 –vrdeaddress “” 打开远程桌面 VBoxManage modifyvm UbuntuRDHome –vrde on 关闭远程桌面 VBoxManage modifyvm UbuntuRDHome –vrde off 查看虚拟机信息VBoxManage -v VBoxManage list vms VBoxManage list runningvms VBoxManage showvminfo UbuntuRDHome VBoxManage list hdds VBoxManage list dvds启动与管理虚拟机启动虚拟机 VBoxManage startvm UbuntuRDHome –type headless 保持状态关闭虚拟机[推荐] VBoxManage controlvm UbuntuRDHome savestate 放弃已保存的状态 VBoxManage discardstate UbuntuRDHome断电关闭虚拟机 VBoxManage controlvm UbuntuRDHome poweroff 正常关机[不能彻底关闭，一直处于stopping状态] VBoxManage controlvm UbuntuRDHome acpipowerbutton 管理虚拟机更多命令 VBoxManage controlvm UbuntuRDHome XXX 高级配置参照着VirtualBox GUI，凡是想要的功能都可以通过命令行执行。设置CPU数量（必须打开IOAPIC） VBoxManage modifyvm UbuntuRDHome --ioapic on VBoxManage modifyvm UbuntuRDHome --cpus 8使能largepages选项 VBoxManage modifyvm UbuntuRDHome –largepages on 设置CPU运行峰值 VBoxManage modifyvm UbuntuRDHome –cpuexecutioncap 80 虚拟硬盘的高级操作VirtualBox的媒体是统一管理的，可以使用list查看： VBoxManage list hdds 克隆媒体（克隆已有的虚拟硬盘文件，之后可以添加到虚拟机） VBoxManage clonemedium hddfilename 移动虚拟硬盘位置（不是简单的cp或mv） VBoxManage modifymedium hddfilename –move “new dir” 快照的创建和恢复（十分重要）这里以创建快照 snap20171204-installed 为例，进行演示。 快照列表： VBoxManage snapshot UbuntuRDHome list VBoxManage snapshot UbuntuRDHome showvminfo snap20171204-installed创建快照： VBoxManage snapshot UbuntuRDHome take snap20171204-installed 删除快照： VBoxManage snapshot UbuntuRDHome delete snap20171204-installed恢复快照： VBoxManage snapshot UbuntuRDHome restore snap20171204-installed 恢复当前快照： VBoxManage snapshot UbuntuRDHome restorecurrent 虚拟机执行命令(重要)在虚拟机执行命令，下边是设置IP为静态IP 的命令 VBoxManage guestcontrol “cuckoo1” –username wintest –password 123456 run –exe “C:\Windows\System32\cmd.exe” – “C:\Windows\System32\cmd.exe” “/c” “netsh interface ip set address “本地连接” static 192.168.56.101 255.255.255.0 192.168.56.1 1” 安装 Guest Additions挂载CD/DVD虚拟光驱 sudo mount -t auto /dev/cdrom /mnt (这里的cdrom是cd的，有时是dvd，具体有什么光驱到 /dev目录下查看)安装 cd /mnt sudo ./VBoxLinuxAdditions.run 重启 sudo reboot]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>VirtualBox, cuckoo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器]]></title>
    <url>%2F2019%2F11%2F27%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[看这一篇就够了,css选择器知识汇总对大多技术人员来说都比较熟悉CSS选择器，举一例子来说，假设给一个p标签增加一个类（class），可是执行后该class中的有些属性并没有起作用。通过Firebug查看，发现没有起作用的属性被覆盖了，这个时候突然意识到了CSS选择器的优先级问题。严格来讲，选择器的种类可以分为三种：标签名选择器、类选择器和ID选择器。而所谓的后代选择器和群组选择器只不过是对前三种选择器的扩展应用。而在标签内写入style=””的方式，应该是CSS的一种引入方式，而不是选择器，因为根本就没有用到选择器。而一般人们将上面这几种方式结合在一起，所以就有了5种或6种选择器了。 最基本的选择器是元素选择器(比如div),ID选择器(比如#header)还有类选择器(比如.tweet)。 一些的不常见的选择器包括伪类选择器(:hover)，很多复杂的CSS3和正则选择器，比如：first-child，class ^= “grid-”。CSS选择器具有高效的继承性，引用Steve Souders的话， CSS选择器效率从高到低的排序如下： 1.id选择器（#myid） 2.类选择器（.myclassname） 3.标签选择器（div,h1,p） 4.相邻选择器（h1+p） 5.子选择器（ul &gt; li） 6.后代选择器（li a） 7.通配符选择器（*） 8.属性选择器（a[rel=”external”]） 9.伪类选择器（a:hover, li:nth-child） 纵使ID选择器很快、高效，但是它也仅仅如此。从Steve Souders的CSS Test我们可以看出ID选择器和类选择器在速度上的差异很小很小。 在Windows系统上的Firefox 6上，我测得了一个简单类选择器的（reflow figure）重绘速度为10.9ms，而ID选择器为12.5ms，所以事实上ID比类选择器重绘要慢一点点。 ID选择器和类选择器在速度上的差异基本上没有关系。 在一个标签选择器(a)的测试上显示，它比类或ID选择器的速度慢了很多。在一个嵌套很深的后代选择器的测试上，显示数据为440左右！从这里我们可以看出ID/类选择器 和 元素/后代选择器中间的差异较大，但是相互之间的差异较小。 选择器的优先级是怎么规定的呢？一般而言，选择器越特殊，它的优先级越高。也就是选择器指向的越准确，它的优先级就越高。通常我们用1表示标签名选择器的优先级，用10表示类选择器的优先级，用100标示ID选择器的优先级。比如上例当中 .polaris span {color:red;}的选择器优先级是 10 + 1 也就是11；而 .polaris 的优先级是10；浏览器自然会显示红色的字。理解了这个道理之后下面的优先级计算自是易如反掌： 12div.test1 .span var 优先级 1+10 +10 +1span#xxx .songs li 优先级1+100 + 10 + 1#xxx li 优先级 100 + 1 对于什么情况下使用什么选择器，用不同选择器的原则是： 1、准确的选到要控制的标签； 2、使用最合理优先级的选择器； 3、HTML和CSS代码尽量简洁美观。通常： ①最常用的选择器是类选择器。 ②li、td、dd等经常大量连续出现，并且样式相同或者相类似的标签，我们采用类选择器跟标签名选择器结合的后代选择器 .xx li/td/dd {} 的方式选择。 ③极少的情况下会用ID选择器，当然很多前端开发人员喜欢header，footer，banner，conntent设置成ID选择器的，因为相同的样式在一个页面里不可能有第二次。 在这里不得不提使用在标签内引入CSS的方式来写CSS，即： 1&lt;div style=&quot;color:red&quot;&gt;polaris&lt;/div&gt; 这时候的优先级是最高的。我们给它的优先级是1000，这种写法不推荐使用，特别是对新手来说。这也完全违背了内容和显示分离的思想。DIV+CSS的优点也不能再有任何体现。 怎么提升CSS选择器性能？1、避免使用通用选择器 1.content &#123;color: red;&#125; 浏览器匹配文档中所有的元素后分别向上逐级匹配 class 为 content 的元素，直到文档的根节点。因此其匹配开销是非常大的，所以应避免使用关键选择器是通配选择器的情况。 2、避免使用标签或 class 选择器限制 id 选择器 12345678BADbutton#backButton &#123;…&#125;BAD.menu-left#newMenuIcon &#123;…&#125;GOOD#backButton &#123;…&#125;GOOD#newMenuIcon &#123;…&#125; 3、避免使用标签限制 class 选择器 123456BADtreecell.indented &#123;…&#125;GOOD.treecell-indented &#123;…&#125;BEST.hierarchy-deep &#123;…&#125; 4、避免使用多层标签选择器。使用 class 选择器替换，减少css查找 1234BADtreeitem[mailfolder=&quot;true&quot;] &gt; treerow &gt; treecell &#123;…&#125;GOOD.treecell-mailfolder &#123;…&#125; 5、避免使用子选择器 123456BADtreehead treerow treecell &#123;…&#125;BETTER, BUT STILL BAD treehead &gt; treerow &gt; treecell &#123;…&#125;GOOD.treecell-header &#123;…&#125; 6、使用继承 1234BAD #bookmarkMenuItem &gt; .menu-left &#123; list-style-image: url(blah) &#125;GOOD#bookmarkMenuItem &#123; list-style-image: url(blah) &#125; 简洁、高效的CSS所谓高效的CSS就是让浏览器在查找style匹配的元素的时候尽量进行少的查找，下面列出一些我们常见的写CSS犯一些低效错误： 不要在ID选择器前使用标签名 一般写法：DIV#divBox 更好写法：#divBox 解释： 因为ID选择器是唯一的，加上div反而增加不必要的匹配。 不要再class选择器前使用标签名 一般写法：span.red 更好写法：.red 解释：同第一条，但如果你定义了多个.red，而且在不同的元素下是样式不一样，则不能去掉，比如你css文件中定义如下： 1p.red&#123;color:red;&#125; span.red&#123;color:#ff00ff&#125; 如果是这样定义的就不要去掉，去掉后就会混淆，不过建议最好不要这样写 尽量少使用层级关系 一般写法：#divBox p .red{color:red;} 更好写法：.red{..} 使用class代替层级关系 一般写法：#divBox ul li a{display:block;} 更好写法：.block{display:block;} 必须记住的30类CSS选择器大概大家都知道“id”,“class”以及“descendant”选择器，并且整体都在使用它们，那么你正在错误拥有更大级别的灵活性的选择方式。下面提到的大部分选择器都是在CSS3标准下的，所以它们只能在相应最新版本的浏览器中才能生效，你完全应该把这些都记在你聪明的脑袋里面。 1.*1234 &#123; margin: 0; padding: 0;&#125; 在我们看比较高级的选择器之前，应该认识下这个众所周知的清空选择器。星号呢会将页面上所有每一个元素都选到。许多开发者都用它来清空margin和padding。当然你在练习的时候使用这个没问题，但是我不建议在生产环境中使用它。它会给浏览器凭添许多不必要的东西。*也可以用来选择某元素的所有子元素。 123#container * &#123; border: 1px solid black;&#125; 它会选中#container下的所有元素。当然，我还是不建议你去使用它，如果可能的话。 兼容性 IE6+ Firefox Chrome Safari Opera 2. #X1234#container &#123; width: 960px; margin: auto;&#125; 在选择器中使用#可以用id来定位某个元素。大家通常都会这么使用，然后使用的时候大家还是得相当小心的。需要问自己一下：我是不是必须要给这个元素来赋值个id来定位它呢？ id选择器是很严格的并且你没办法去复用它。如果可能的话，首先试试用标签名字，HTML5中的新元素，或者是伪类。 兼容性 IE6+ Firefox Chrome Safari Opera 3. .X123.error &#123; color: red;&#125; 这是个class选择器。它跟id选择器不同的是，它可以定位多个元素。当你想对多个元素进行样式修饰的时候就可以使用class。当你要对某个特定的元素进行修饰那就是用id来定位它。 兼容性 IE6+ Firefox Chrome Safari Opera 4. X Y123li a &#123; text-decoration: none;&#125; 下一个常用的就是descendant选择器。如果你想更加具体的去定位元素，你可以使用它。例如，假如，你不需要定位所有的a元素，而只需要定位li标签下的a标签？这时候你就需要使用descendant选择器了。 专家提示：如果你的选择器像X Y Z A B.error这样，那你就错了。时刻都提醒自己，是否真的需要对那么多元素修饰。 兼容性 IE6+ Firefox Chrome Safari Opera 5. X12a &#123; color: red; &#125;ul &#123; margin-left: 0; &#125; 如果你想定位页面上所有的某标签，不是通过id或者是’class’，这简单，直接使用类型选择器。 兼容性 IE6+ Firefox Chrome Safari Opera 6. X:visited and X:link12a:link &#123;color:red;&#125;a:visited &#123;color: purple;&#125; 我们使用:link这个伪类来定位所有还没有被访问过的链接。 另外，我们也使用:visited来定位所有已经被访问过的链接。 兼容性 IE7+ Firefox Chrome Safari Opera 7. X+Y123ul + p &#123; color: red;&#125; 这个叫相邻选择器。它指挥选中指定元素的直接后继元素。上面那个例子就是选中了所有ul标签后面的第一段，并将它们的颜色都设置为红色。 兼容性 IE7+ Firefox Chrome Safari Opera 8. X&gt;Y123div#container &gt; ul &#123; border: 1px solid black;&#125; X Y和X &gt; Y的差别就是后面这个指挥选择它的直接子元素。看下面的例子： 123456789101112&lt;div id=&quot;container&quot;&gt; &lt;ul&gt; &lt;li&gt; List Item &lt;ul&gt; &lt;li&gt; Child &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt; List Item &lt;/li&gt; &lt;li&gt; List Item &lt;/li&gt; &lt;li&gt; List Item &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; #container &gt; ul只会选中id为’container’的div下的所有直接ul元素。它不会定位到如第一个li下的ul元素。 由于某些原因，使用子节点组合选择器会在性能上有许多的优势。事实上，当在javascript中使用css选择器时候是强烈建议这么做的。 兼容性 IE7+ Firefox Chrome Safari Opera 9. X ~ Y123ul ~ p &#123; color: red;&#125; 兄弟节点组合选择器跟X+Y很相似，然后它又不是那么的严格。ul + p选择器只会选择紧挨跟着指定元素的那些元素。而这个选择器，会选择跟在目标元素后面的所有匹配的元素。 兼容性 IE7+ Firefox Chrome Safari Opera 10. X[title]123a[title] &#123; color: green;&#125; 这个叫属性选择器，上面的这个例子中，只会选择有title属性的元素。那些没有此属性的锚点标签将不会被这个代码修饰。那再想想如果你想更加具体的去筛选？那… 兼容性 IE7+ Firefox Chrome Safari Opera 11. X[href=”foo”]123a[href=&quot;http://strongme.cn&quot;] &#123; color: #1f6053; /* nettuts green */&#125; 上面这片代码将会把href属性值为http://strongme.cn的锚点标签设置为绿色，而其他标签则不受影响。 注意我们将值用双引号括起来了。那么在使用Javascript的时候也要使用双引号括起来。可以的话，尽量使用标准的CSS3选择器。 这样可以用了，但是还是有点死，如果不是这个链接，而是类似的链接，那么这时就得用正则表达式了。 兼容性 IE7+ Firefox Chrome Safari Opera 12. X[href=”strongme”]123a[href=&quot;strongme&quot;] &#123; color: #1f6053;&#125; Tada,正是我们需要的，这样，就指定了strongme这个值必须出现在锚点标签的href属性中，不管是strongme.cn还是strongme.com还是www.strongme.cn都可以被选中。但是记得这是个很宽泛的表达方式。如果锚点标签指向的不是strongme相关的站点，如果要更加具体的限制的话，那就使用^和$，分别表示字符串的开始和结束。 兼容性 IE7+ Firefox Chrome Safari Opera 13. X[href^=”href”]1234a[href^=&quot;http&quot;] &#123; background: url(path/to/external/icon.png) no-repeat; padding-left: 10px;&#125; 大家肯定好奇过，有些站点的锚点标签旁边会有一个外链图标，我也相信大家肯定见过这种情况。这样的设计会很明确的告诉你会跳转到别的网站。用克拉符号就可以轻易做到。它通常使用在正则表达式中标识开头。如果我们想定位锚点属性href中以http开头的标签，那我们就可以用与上面相似的代码。 注意我们没有搜索http://，那是没必要的，因为它都不包含https://。 那如果我们想找到所有指向一张图片的锚点标签呢？那我们来使用下&amp;字符。 兼容性 IE7+ Firefox Chrome Safari Opera 14. X[href$=”.jpg”]123a[href$=&quot;.jpg&quot;] &#123; color: red;&#125; 这次我们又使用了正则表达式$，表示字符串的结尾处。这段代码的意思就是去搜索所有的图片链接，或者其它链接是以.jpg结尾的。但是记住这种写法是不会对gifs和pngs起作用的。 兼容性 IE7+ Firefox Chrome Safari Opera 15. X[data-*=”foo”]123a[data-filetype=&quot;image&quot;] &#123; color: red;&#125; 在回到第8条，我们如何把所有的图片类型都选中呢png,jpeg,’jpg’,’gif’？我们可以使用多选择器。看下面： 123456a[href$=&quot;.jpg&quot;],a[href$=&quot;.jpeg&quot;],a[href$=&quot;.png&quot;],a[href$=&quot;.gif&quot;] &#123; color: red;&#125; 但是这样写着很蛋疼啊，而且效率会很低。另外一个办法就是使用自定义属性。我们可以给每个锚点加个属性data-filetype指定这个链接指向的图片类型。[html]Image Link 那有了这个钩子，我们就可以去用标准的办法只去选定文件类型为image的锚点了。 123a[data-filetype=&quot;image&quot;] &#123; color: red;&#125; 兼容性 IE7+ Firefox Chrome Safari Opera 16. X[foo~=”bar”]123456a[data-info~=&quot;external&quot;] &#123; color: red;&#125;a[data-info~=&quot;image&quot;] &#123; border: 1px solid black;&#125; 这个我想会让你的小伙伴惊呼妙极了。很少有人知道这个技巧。这个~符号可以定位那些某属性值是空格分隔多值的标签。继续使用第15条那个例子，我们可以设置一个data-info属性，它可以用来设置任何我们需要的空格分隔的值。这个例子我们将指示它们为外部连接和图片链接。 1Click Me, Fool 给这些元素设置了这个标志之后，我们就可以使用~来定位这些标签了。 12345678/ Target data-info attr that contains the value &quot;external&quot; /a[data-info~=&quot;external&quot;] &#123; color: red;&#125;/ And which contain the value &quot;image&quot; /a[data-info~=&quot;image&quot;] &#123; border: 1px solid black;&#125; ## 17. X:checked 123input[type=radio]:checked &#123; border: 1px solid black;&#125; 上面这个伪类写法可以定位那些被选中的单选框和多选框，就是这么简单。 兼容性 IE9+ Firefox Chrome Safari Opera 18. X:afterbefore和after这俩伪类。好像每天大家都能找到使用它们的创造性方法。它们会在被选中的标签周围生成一些内容。当使用.clear-fix技巧时许多属性都是第一次被使用到里面的。 123456789101112.clearfix:after &#123; content: &quot;&quot;; display: block; clear: both; visibility: hidden; font-size: 0; height: 0; &#125;.clearfix &#123; display: inline-block; _height: 1%;&#125; 上面这段代码会在目标标签后面补上一段空白，然后将它清除。这个方法你一定得放你的聚宝盆里面。特别是当overflow:hidden方法不顶用的时候，这招就特别管用了。 根据CSS3标准规定，可以使用两个冒号::。然后为了兼容性，浏览器也会接受一个双引号的写法。其实在这个情况下，用一个冒号还是比较明智的。 兼容性 IE8+ Firefox Chrome Safari Opera 19. X:hover123div:hover &#123; background: #e3e3e3;&#125; 不用说，大家肯定知道它。官方的说法是user action pseudo class.听起来有点儿迷糊，其实还好。如果想在用户鼠标飘过的地方涂点儿彩，那这个伪类写法可以办到。 注意旧版本的IE只会对加在锚点a标签上的:hover伪类起作用。 通常大家在鼠标飘过锚点链接时候加下边框的时候用到它。 123a:hover &#123; border-bottom: 1px solid black;&#125; 专家提示：border-bottom:1px solid black;比text-decoration:underline;要好看很多。 兼容性 IE6+(IE6只能在锚点标签上起作用) Firefox Chrome Safari Opera 20. X:not(selector)123div:not(#container) &#123; color: blue;&#125; 取反伪类是相当有用的，假设我们要把除id为container之外的所有div标签都选中。那上面那么代码就可以做到。 或者说我想选中所有出段落标签之外的所有标签。 123:not(p) &#123; color: green;&#125; 兼容性 IE9+ Firefox Chrome Safari Opera 21. X::pseudoElement1234p::first-line &#123; font-weight: bold; font-size:1.2em;&#125; 我们可以使用::来选中某标签的部分内容，如第一段，或者是第一个字没有。但是记得必须使用在块式标签上才起作用。 伪标签是由两个冒号 :: 组成的。 定位第一个字 1234567p::first-letter &#123; float: left; font-size: 2em; font-weight: bold; font-family: cursive; padding-right: 2px;&#125; 上面这段代码会找到页面上所有段落，并且指定为每一段的第一个字。 它通常在一些新闻报刊内容的重点突出会使用到。 定位某段的第一行 1234p::first-line &#123; font-weight: bold; font-size: 1.2em;&#125; 跟::first-line相似，会选中段落的第一行 。 为了兼容性，之前旧版浏览器也会兼容单冒号的写法，例如:first-line,:first-letter,:before,:after.但是这个兼容对新介绍的特性不起作用。 兼容性 IE6+ Firefox Chrome Safari Opera 22. X:nth-child(n)123li:nth-child(3) &#123; color: red;&#125; 还记得我们面对如何取到推跌式标签的第几个元素是无处下手的时光么，有了nth-child那日子就一去不复返了。 请注意nth-child接受一个整形参数，然后它不是从0开始的。如果你想获取第二个元素那么你传的值就是li:nth-child(2). 我们甚至可以获取到由变量名定义的个数个子标签。例如我们可以用li:nth-child(4n)去每隔3个元素获取一次标签。 兼容性 IE9+ Firefox3.5+ Chrome Safari 23. X:nth-last-child(n)123li:nth-last-child(2) &#123; color: red;&#125; 假设你在一个ul标签中有N多的元素，而你只想获取最后三个元素，甚至是这样li:nth-child(397)，你可以用nth-last-child伪类去代替它。 这个技巧可以很正确的代替第16个TIP，不同的就是它是从结尾处开始的，倒回去的。 兼容性 IE9+ Firefox3.5+ Chrome Safari Opera 24. X:nth-of-type(n)123ul:nth-of-type(3) &#123; border: 1px solid black;&#125; 曾几何时，我们不想去选择子节点，而是想根据元素的类型来进行选择。 想象一下有5个ul标签。如果你只想对其中的第三个进行修饰，而且你也不想使用id属性，那你就可以使用nth-of-type(n)伪类来实现了，上面的那个代码，只有第三个ul标签会被设置边框。 兼容性 IE9+ Firefox3.5+ Chrome Safari 25. X:nth-last-of-type(n)123ul:nth-last-of-type(3) &#123; border: 1px solid black;&#125; 同样，也可以类似的使用nth-last-of-type来倒序的获取标签。 兼容性 IE9+ Firefox3.5+ Chrome Safari Opera 26. X:first-child123ul li:first-child &#123; border-top: none;&#125; 这个结构性的伪类可以选择到第一个子标签，你会经常使用它来取出第一个和最后一个的边框。 假设有个列表，每个标签都有上下边框，那么效果就是第一个和最后一个就会看起来有点奇怪。这时候就可以使用这个伪类来处理这种情况了。 兼容性 IE7+ Firefox Chrome Safari Opera 27. X:last-child123ul &gt; li:last-child &#123; color: green;&#125; 跟first-child相反，last-child取的是父标签的最后一个标签。 例如标签 123List Item List Item List Item 这里没啥内容，就是一个了 List。 123456789101112ul &#123; width: 200px; background: #292929; color: white; list-style: none; padding-left: 0;&#125;li &#123; padding: 10px; border-bottom: 1px solid black; border-top: 1px solid #3c3c3c;&#125; 上面的代码将设置背景色，移除浏览器默认的内边距，为每个li设置边框以凸显一定的深度。 兼容性 IE9+ Firefox Chrome Safari Opera 28. X:only-child123div p:only-child &#123; color: red;&#125; 说实话，你会发现你几乎都不会用到这个伪类。然而，它是可用的，有会需要它的。 它允许你获取到那些只有一个子标签的父标签。就像上面那段代码，只有一个段落标签的div才被着色。 1234My paragraph here. Two paragraphs total. Two paragraphs total. 上面例子中，第二个div不会被选中。一旦第一个div有了多个子段落，那这个就不再起作用了。 兼容性 IE9+ Firefox Chrome Safari Opera 29. X:only-of-type123li:only-of-type &#123; font-weight: bold;&#125; 结构性伪类可以用的很聪明。它会定位某标签只有一个子标签的目标。设想你想获取到只有一个子标签的ul标签？ 使用ul li会选中所有li标签。这时候就要使用only-of-type了。 123ul &gt; li:only-of-type &#123; font-weight: bold;&#125; 兼容性 IE9+ Firefox 3.5+ Chrome Safari Opera **** 30. X:first-of-type first-of-type 伪类可以选择指定标签的第一个兄弟标签。 测试 123456789My paragraph here. List Item 1 List Item 2 List Item 3 List Item 4 来你把List Item 2取出来，如果你已经取出来或者是放弃了，来继续。 解决办法1办法很多，我们看一些比较方便的。首先是first-of-type。 123ul:first-of-type &gt; li:nth-child(2) &#123; font-weight: bold;&#125; 找到第一个ul标签，然后找到直接子标签li，然后找到第二个子节点。解决办法2另一个解决办法就是邻近选择器。 123p + ul li:last-child &#123; font-weight: bold;&#125; 这种情况下，找到p下的直接ul标签，然后找到它的最后一个直接子标签。 解决办法3我们可以随便玩耍这些选择器。来看看： 123ul:first-of-type li:nth-last-child(1) &#123; font-weight: bold;&#125; 先获取到页面上第一个ul标签，然后找到最后一个子标签。 兼容性 IE9+ Firefox 3.5+ Chrome Safari Opera 结论如果你想向旧版本浏览器妥协，比如IE6，那你用这些新的选择器的时候还是得小心点。但别让IE6阻止你去学这些新的技能。那你就对自己太残忍了。记得多查查兼容性列表，或者使用Dean Edward’s excellent IE9.js script 来让你的浏览器具有这些特性。 第二个，使用向jQuery的时候，尽量使用原生的CSS3选择器。可能 活让你的代码跑的很快。这样选择器引擎就可以使用浏览器原生解析器，而不是选择器自己的。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARP协议]]></title>
    <url>%2F2019%2F10%2F22%2F%E5%9B%BE%E8%A7%A3ARP%E5%8D%8F%E8%AE%AE%EF%BC%88%E4%BA%8C%EF%BC%89ARP%E6%94%BB%E5%87%BB%E7%AF%87%2F</url>
    <content type="text"><![CDATA[ARP攻击篇 一、ARP攻击概述在上篇文章里，我给大家普及了ARP协议的基本原理，包括ARP请求应答、数据包结构以及协议分层标准，今天我们继续讨论大家最感兴趣的话题：ARP攻击原理是什么？通过ARP攻击可以做什么，账号是否可以被窃取？有哪些常见的ARP渗透（攻击）工具可以用来练手？ARP扫描和攻击有什么区别，底层数据包特征是怎样的？ 接下来，我们通过图解的方式来深入了解ARP攻击是如何实现的。 二、ARP攻击原理但凡局域网存在ARP攻击，都说明网络存在”中间人”，我们可以用下图来解释。 在这个局域网里面，PC1、PC2、PC3三台主机共同连接到交换机SW1上面，对应3个接口port1/2/3。假设PC3这台主机安装了ARP攻击软件或遭受ARP病毒，成为这个网络的攻击者（hacker），接下来，PC3是如何攻击的？先不急，先来回顾下PC1和PC2是如何通信的。 ①PC1需要跟PC2通信，通过ARP请求包询问PC2的MAC地址，由于采用广播形式，所以交换机将ARP请求包从接口P1广播到P2和PC3。（注：交换机收到广播/组播/未知帧都会其他接口泛洪） ②PC2根据询问信息，返回ARP单播回应包；此时PC3作为攻击者，没有返回ARP包，但是处于”监听“状态，为后续攻击做准备。 ③PC1和PC2根据ARP问答，将各自的ARP映射信息（IP-MAC）存储在本地ARP缓存表。 ④交换机根据其学习机制，记录MAC地址对应的接口信息，存储在CAM缓存表（也称为MAC地址表）。交换机收到数据包时，会解封装数据包，根据目标MAC字段进行转发。 关于上面的图解，我们要记住这些关键知识（敲黑板！）： ①主机通信需要查找ARP表，而交换机通信需要查找CAM表（路由器则查找Route表）。 注：ARP表：ip&lt;-&gt;mac CAM表：mac&lt;-&gt;port （Route表：route&lt;-&gt;port） ②交换机基于源MAC地址学习，基于目的MAC地址转发。 ③同一局域网内，攻击者可以根据主机的ARP广播请求监听其IP和MAC信息。 注：这里是”被动监听”，跟后面要谈到的”主动扫描”，原理上有区分，这里先埋个坑） 接下来是重点，我们来看看PC3（Hacker）是如何发起ARP攻击的=&gt; 正常情况下，若收到的ARP请求不是给自己的，则直接丢弃；而这里PC3（Hacker）在监听之后，发起了ARP回应包：我就是PC2（IP2-MAC3）。 从拓扑可以出现，PC3明明是IP3对应MAC3，很显然这就是一个ARP欺骗行为。于此同时，PC2正常的ARP回应包也交到了PC1手中，我们来看PC1接下来如何处理的： PC1收到两个ARP回应包，内容分别如下： ③我是PC2，我的IP地址是IP2，我的MAC地址是MAC2； ③我是PC2，我的IP地址是IP2，我的MAC地址是MAC3； PC1一脸懵：咋回事？还有这操作？**不管了，我选最新的！（后到优先）** 这里给大家顺便普及下网络协议里各种表在处理缓存信息的方式： 要么”先到先得”，要么”后到优先”。上面提到的ARP和CAM表，就是遵循”后到优先”原则，而后面章节我们会讲到的DHCP表，则遵循”先到先得”原则。 那么问题来了，上面两个ARP回应包到底哪个先到哪个后到呢？ 作为初学者，可能还在纠结前后这种naive的问题；而作为hacker，只要持续不停发出ARP欺骗包，就一定能够覆盖掉正常的ARP回应包。稳健的ARP嗅探/渗透工具，能在短时间内高并发做网络扫描（例如1秒钟成千上百的数据包），能够持续对外发送欺骗包。 无论如何，当PC1和PC2这种”小白”用户遇到PC3（hacker）时，最终的结果一定是这样的： 小白 vs 黑客，很明显的较量，PC1最终记录的是虚假的ARP映射：IP2&lt;-&gt;MAC3，得到错误信息的PC1，接下来会发生什么情况呢？（我们以PC1 ping PC2为例） 根据数据封装规则，当PC1要跟PC2进行通信时，无论是发生PING包还是发送其他数据，首先要查找ARP表，然后在网络层打上源目IP，在链路层打上源目MAC，然后将数据包发送给交换机。交换机收到之后对数据进行解封装，并且查看CAM表（基于目的MAC转发），由于目标MAC3对应Port3，所以交换机自然而然将其转发给PC3。 就这样，PC1本来要发给PC2的数据包，落到了PC3（Hacker）手里，这就完成了一次完整的ARP攻击。反过来，如果PC2要将数据包发送给PC1，PC3仍然可以以同样的ARP欺骗实现攻击，这就有了下面这张图（PC3既欺骗了PC1，也欺骗了PC2）。 此时，PC1和PC2的通信数据流被PC3拦截，形成了典型的”中间人攻击“。那么，一旦被攻击并拦截，攻击者能做什么，普通用户又会遭受什么损失？这里给大家举几个常见的例子=&gt; ①攻击者既然操控了数据流，那么直接断开通信是轻而易举的，即“断网攻击”，例如，PC1发给PC2的数据在PC3这里可以直接丢弃，而如果这里的PC2是一台出口路由器（无线路由器），那就意味着PC1直接无法连上互联网。 ②”断网攻击”显然容易被发现，而且比较”残忍”，所以就有了更加常见的应用-“限速”。例如，在宿舍上网突然很慢，在网吧上网突然打不开网页，如果这个网络没有安全防御，那么很有可能有”内鬼”。 ③其实无论是”断网攻击”还是”限速”，整体还是比较”善良”，因为这里流量里面的核心数据还没有被”提取”出来。如果攻击者是一名真正的黑客，他的目的一定不会这么无聊，因为内网流量对于黑客是没有太大价值的，而只有“用户隐私”，例如常见网站的登录账号密码，这些才是最有价值的。 问：遭受ARP攻击之后，哪些账号可能被窃取？ 答：任何基于明文传输的应用，都可以被窃取。例如，如果一个网站不是HTTPS协议，而是基于HTTP明文传输，那么当你登录这个网站时，你的密码就会被窃取。除了http（web应用），常见的还有telnet、ftp、pop3/smtp/imap（邮箱）等应用，都很容易泄露密码。 三、常见ARP渗透工具与底层原理分析基于ARP欺骗原理设计出来的渗透/攻击工具非常多，而最终能实现什么功能则各有差异，简单举几个例子： ①无毒无害型的仅具备ARP扫描功能，用来发现内网主机；例如Metasploit里面的arping/arpscan相关模块； ②ARP扫描+流量控制（限速或限制能上哪些网站和应用）；例如Windows下的P2P终结者； ③ARP扫描+账号窃取（网站、邮箱、各种）；最强的莫过于Windows下的Cain，当然还有跨平台的Ettercap（需配合其他工具）； 当然，如果攻击者足够强悍，也可以基于协议底层原理，编写自己的ARP工具。这里我通过wirehshark给大家还原真实网络中常见的ARP扫描和欺骗攻击（具体的软件使用这里暂时不出现，大家重点关注底层实现）。 在这张图里面，Hacker（就是我…）接入了一个WiFi网络，这个10.1.20.0/24便是所在的网段。刚进来一个陌生网络，Hacker只知道自己的IP信息，例如IP地址是10.1.20.253，网关地址是10.1.20.254，而这个局域网的其他设备是什么？有多少台？地址分布是多少？Hacker都不知道，接下来怎么办呢？是不是要直接发动ARP攻击了？ 不用这么着急，咋们至少要先了解下这个网络，进行基本的扫描和踩点。这个时候通过ARP工具对这个WiFi网络进行扫描，具体的数据包截图如下： 上面的ARP扫描过程，大概的情况是这样的=&gt; 其实，这就是典型的”盲扫”或者”暴力扫描”：反正我不知道网络到底有多少主机，那我就尝试一下把整个网段全部问一遍得了。好比老师上课点名，把每个学生的桌位号念一遍，谁举手就到勤，没举手就算逃课。 那么，这个实际网络里面，到底谁”举手”了呢？我们来看Wireshark抓包情况。 在ARP应答信息里面，除了IP地址和MAC信息，我们还能看到相关的设备厂商信息，例如cisco、meizu、apple、xiaomi等，这其实就是依靠MAC地址前面24位的OUI（机构唯一标识符）来识别的。 Wireshark或扫描器能够帮我们将OUI转为对应的厂商（还有一些扫描器基于Netbios协议，还能找到电脑的主机名），所以，扫描之后可以得到下面这张图片=&gt; 通过扫描，我们已经知道了整个网络的主机信息，例如20.254对应cisco，应该是路由器，20.248对应apple，是苹果手机，20.249对应xiaomi，是小米手机，以此类推….. 接下来，如何进行ARP欺骗攻击呢？这里将最重点的数据包截取出来=&gt; 根据之前的信息，我们知道00:08:ca:86:f8:0f其实就是hacker的mac地址，并且对应的真正的IP地址应该是10.1.20.253。而这里很明显是hacker在欺骗局域网其他主机，它对外声称：自己就是”所有人”。尤其是上面标红的主机，我们已经知道是小米、思科、苹果等设备，但是hacker都声明是自己！这样做的意义在于覆盖掉其他主机的ARP缓存表信息，并生成错误的ARP映射，最终将通信流量交给hacker。 当然，还有另外一种ARP欺骗的做法：hacker告诉所有人，自己就是网关。因为其他主机访问互联网必经之路便是网关（出口路由器/无线路由器），通过这种方式，同样可以截取到用户数据流，这里给出另外一个网络的实现过程=&gt; Hacker欺骗主机Honhai，告诉它：我就是网关（10.1.1.254） Hacker欺骗主机Apple，告诉它：我就是网关（10.1.1.254） 依此类推，Hacker会告诉局域网所有主机：自己就是网关，并且后续可以把数据都丢给我，我来转发到互联网。 四、ARP攻击总结①ARP缓存表基于”后到优先”原则，IP与MAC的映射信息能被覆盖； ②ARP攻击基于伪造的ARP回应包，黑客通过构造”错位”的IP和MAC映射，覆盖主机的ARP表（也被称为”ARP毒化”），最终截取用户的数据流； ③一旦遭受ARP攻击，账号密码都可能被窃取（如果通信协议不是加密的）； ④通过Wireshark数据包分析，我们掌握了真实网络中ARP底层攻击原理及数据包组成。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web-basic protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免杀的艺术(三)]]></title>
    <url>%2F2019%2F10%2F16%2F%E5%85%8D%E6%9D%80%E7%9A%84%E8%89%BA%E6%9C%AF(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[免杀的艺术(一) 免杀的艺术(二) 免杀的艺术(三) 免杀的艺术(三)我们在上一篇提到要要自定义shellcode，不过由于这是个复杂的过程，我们只能专门写一篇了，本文，我们将会给大家介绍shellcode的基本概念，shellcode在编码器及解码器中的汇编以及几种绕过安全检测的解决方案，例如如何绕过微软的 EMET（一款用以减少软件漏洞被利用的安全软件）。为了理解本文的内容，大家需要具了解x86汇编知识和基本文件格式（如COFF和PE）。 专业术语进程环境块（PEB）：PEB(Process Environment Block)是Windows NT操作系统中的一种数据结构。由于PEB仅在Windows NT操作系统内部使用，其大多数字段不面向其他操作系统，所以PEB就不是一个透明的数据结构。微软已在其MSDN Library技术开发文档中开始修改PEB的结构属性。它包含了映像加载器、堆管理器和其他的windows系统DLL所需要的信息，因为需要在用户模式下修改PEB中的信息，所以必须位于用户空间。PEB存放进程信息，每个进程都有自己的 PEB 信息。准确的 PEB 地址应从系统的 EPROCESS 结构的 1b0H 偏移处获得，但由于 EPROCESS在进程的核心内存区，所以程序不能直接访问。 导入地址表（IAT）：IAT （Import Address Table）由于导入函数就是被程序调用但其执行代码又不在程序中的函数，这些函数的代码位于一个或者多个DLL 中，当PE 文件被装入内存的时候，Windows 装载器才将DLL 装入，并将调用导入函数的指令和函数实际所处的地址联系起来(动态连接)，这操作就需要导入表完成.其中导入地址表就指示函数实际地址。 数据执行保护（DEP）：与防病毒程序不同，数据执行保护（DEP）是一组对内存区域进行监控的硬件和软件技术，DEP技术的目的并不是防止在计算机上安装有害程序。 而是监视你的已安装程序，帮助确定它们是否正在安全地使用系统内存。在Microsoft Windows XP Service Pack 2（SP2）和Microsoft Windows XP Tablet PC的2005版中，DEP是通过硬件和软件来运行的。DEP的主要优点是阻止代码在数据页中运行。通常，代码不会在默认堆和堆栈中执行。而硬件可以强制DEP检测在这些位置运行的代码，当运行发生异常时，软件就可以通过DEP阻止恶意代码利用Windows中的异常处理机制。 stdcall调用约定：stdcall调用约定相当于16位动态库中经常使用的PASCAL调用约定。调用约定是用来清理堆栈的，和cdecl类似，stdcall调用约定也是按从右至左的顺序压参数入栈，由调用者把参数弹出栈。stdcall调用是把函数参数列表的前三个参数放入寄存器eax,edx,ecx 。返回值存储在EAX寄存器中。 stdcall是Microsoft Win32 API和Open Watcom C ++的标准调用约定。stdcall是微软win32 API和open Watcom C++的标准调用约定。 Shellcodes在网络安全领域起着非常重要的作用，它们被广泛应用于许多恶意软件和漏洞。那么，为什么shellcode会如此受到恶意程序的欢迎？ Shellcode实际是一段代码（也可以是填充数据），是用来发送到服务器利用特定漏洞的代码，一般可以获取权限。另外，Shellcode一般是作为数据发送给受攻击服务器的， Shellcode是溢出程序和蠕虫病毒的核心。 之所以命名为shellcode，是因为shellcode运行完以后都会返回一个命令行shell，但如今几乎所有的编译器生成的程序都能转化为shellcode。因为编写shellcode涉及到深入理解目标架构和操作系统的汇编语言。虽然我们可以在网上找到很多开源的shellcode，但为了达到不同的使用目的，每个安全研究员都会自己编写一个各自的shellcode，同时重新编写的过程也是理解shellcode的过程。 所以，本文的目标就是要教你如何在不同的检测环境下，重编自己的shellcode。 基本的Shellcode编程与Windows不同，为不同操作系统而编写的shellcode需要不同的编写方法，比如基于UNIX的操作系统提供了通过int 0x80接口与内核通信的直接方式，基于UNIX的操作系统中的所有系统调用都有唯一的编号，比如int 0x80就代表系统调用时设置中断向量号0x80的中断描述符，内核使用给定的数字和参数执行系统调用，但是这里会有一个问题，Windows系统并没有直接的内核接口，这意味着系统调用必须有精确内存地址（函数指针），但经过硬编码的函数地址并不能完全解决这个问题，因为Windows系统的每个函数地址会因为版本中甚至配置不同而发生变化，所以，shellcod e的编写一定要考虑系统的版本，如果要在Windows上编写不受系统版本影响的shellcode，我们只要解决地址问题，这可以通过在运行时动态地找到函数地址来实现。 解决寻址问题在本文中，我们将会使用解析PEB的方法来解决寻址的问题，简单来说，该方法就是使用PEB数据结构来定位基地址的加载DLL，从而解析出EAT及其函数地址，目前几乎所有的不受系统版本影响的shellcode的编写都是用这个技术得到Windows API函数地址的。 在解析PEB的方法中，我们利用“FS”段寄存器，“FS”段寄存器可以指向在微软系统环境中线程环境块（TEB）的基地址，TEB是在用户模式中分配和初始化的内存块，TEB耗用一个内存页（4KB），主要包括：线程异常处理链首、线程本地存储数据以及由GDI和OpenGL图形使用的一些数据结构，当在内存区运行shellcode时，我们需要将TEB向前偏移48字节， 如下图所示，现在我们就找到了PEB的结构体指针， 在获得PEB的结构体指针后，现在我们将PEB结构的起始位置向前偏移12个字节，以便获得PEB块内的LDR数据结构的地址， LDR数据结构包含关于进程已加载模块的信息，如果我们把LDR数据结构再进一步移动20个字节，我们就可以获得进程dll中的 “InMemoryOrderModuleList” 加载模块， 现在我们的指针指向InMemoryOrderModuleList，它是一个LIST_ENTRY结构，Windows将这个结构定义为一个“包含加载的进程模块的双向链表头”。列表中的每个项都是一个指向LDR_DATA_TABLE_ENTRY结构的指针，这个结构是我们的主要目标，它包含加载的DLL（模块）的全名和基地址，因为加载的模块的顺序可以改变，我们应该检查全名，以便选择正确的DLL，其中包含函数正在寻找，这可以很容易做到从LDR_DATA_TABLE_ENTRY开始向前移动40个字节，如果DLL名称匹配我们正在寻找的，我们可以继续，在LDR_DATA_TABLE_ENTRY内向前移动16个字节，我们现在终于有基地加载的DLL的地址， 现在PEB的指针指向了InMemoryOrderModuleList，InMemoryOrderModuleList是一个LIST_ENTRY结构，微软将其定义为“包含加载进程模块的双向链表头”。 由于InMemoryOrderModuleList字段是一个指针，指向LDR_DATA_TABLE_ENTRY 结构体上的LIST_ENTRY字段。但是它不是指向LDR_DATA_TABLE_ENTRY 起始位置的指针，而是指向这个结构的InMemoryOrderLinks字段。所以我们需要想办法让InMemoryOrderModuleList指向LDR_DATA_TABLE_ENTRY。 LDR_DATA_TABLE_ENTRY包含加载模块的所有地址和名称，因为模块加载的顺序可能改变，我们在加载的时候，应该校验加载模块的全名，以便选择包含我们要查找的函数的动态库。我们可以把LDR_DATA_TABLE_ENTRY向前位移40个字节，如果DLL名称匹配，则证明是我们需要的动态库，然后我们继续把LDR_DATA_TABLE_ENTRY向前位移16个字节，就能得到具有基地址的加载模块了。 至此，我们就完成了获得函数地址的第一步，现在我们有了包含所需函数的DLL的基地址，所以，我们就必须解析DLL的导出地址表，以便能找到所需的函数地址，导出地址表位于能在PE头部的可选位置内，从基址向前移60个字节，我们就得到了含有DLL的PE头的内存地址， 最后我们需要用“模块基地址+ PE头地址+ 120字节”这个公式计算出地址表的地址，至此，地址表的地址就被导出了，在得到EAT地址后，我们就可以访问由DLL导出的所有函数，IMAGE_EXPORT_DIRECTORY的结构如下所示， 此结构包含导出函数的地址，名称和数量，使用相同大小的遍历统计计算，可以在此结构内获得所需的函数地址，当然，导出函数的顺序可能会因系统版本不同而异，因此我们要在获取函数地址之前，对函数名称进行校验，在确定函数名称之后，函数地址的计算就好比计算几个Windows数据结构的大小，因为你可以理解这个方法是关于计算几个Windows数据结构的大小，并在内存中遍历，不过在计算函数地址时，真正的挑战是要建立一个可靠的名称比较机制来选择正确的DLL和函数，如果PEB解析技术太难实现，我们还会为你介绍一种更简单的方法。 Hash APImetasploit项目中几乎所有的shellcode都使用一个名为Hash API的汇编块，它是由Stephen Fewer编写的一段代码，自2009年被公布以来，大多数Windows的Windows shellcode就一直在使用它。这个汇编块使得解析PEB结构更容易，它使用基本的PEB解析逻辑和一些额外的Hash算法来快速找到所需的函数，通过计算ROR13函数和模块名的哈希值，可以让这个汇编块的使用起来更加容易，Hash API的汇编块使用stdcall调用约定时，所需的函数参数需要包含ROR13函数名的哈希值和包含该函数的DLL名，在得到我们所需要的参数和函数哈希值之后，如前面所述，这时就该解析PEB块，并找到模块名称了，然后计算ROR13哈希值并将其保存到堆栈，最后再把这个哈希值移动到DLL的导出地址表并计算每个函数名称的ROR13哈希值，ROR13哈希值等于每个函数名称哈希值和模块名称哈希值的和， 如果匹配到我们要找的哈希值，意味着想要的函数被找到了，最后Hash API会使用栈上的参数跳转到找到的函数地址执行。虽然我们最后会得到一段非常简洁实用的代码，但由于其广泛的使用，一些杀毒软件已经可以检测到它了，甚至连一些杀毒软件已经把使用ROR13哈希的列入到恶意程序黑名单了，不过配合使用一些编码机制，目前该方法还是能绕过杀毒软件的。 不过我们还是能找到其他方法来找寻找到API函数地址。 编码器和解码器的设计在开始设计之前，我们要先像大家讲清楚，单独使用这个编码器课不会产生完全不可检测的shellcode，因为在运行shellcode之后，解码器将直接运行并将整个shellcode解码为其原始形式，这当然不能绕过具有动态分析机制的杀毒软件了， 解码器逻辑非常简单，它将使用随机生成的多字节XOR键来解码shellcode，在解码操作之后它将执行它，在将shellcode放置在解码器头部之前，应该使用多字节XOR密钥加密， shellcode和XOR键应放在“”，“”标签内， 解码器的逻辑非常简单，就是使用一个随机生成的多字节XOR密钥来解码shellcode，在解码操作完成后运行shellcode，在将shellcode放置在解码器头部之前，应该使用多字节XOR密钥来对shellcode加密，这时shellcode和XOR密钥就分别位于“”和””标签内。 我们在此使用了JMP及CALL的指令来获得shellcode和密钥的地址，然后在shellcode和密钥的每个字节都要执行一次逻辑XOR操作，每次解密密钥运行到末尾时，JMP及CALL指令都会把密钥重置为起始地址，在完成解码操作之后，JMP及CALL指令将调用跳转到shellcode，使用字节更长的XOR密钥来增加shellcode的随机性，但如此反复的操作也增加代码块信息熵的大小。 因此要避免使用太长的解密密钥，经过我们的测试，使用基本的逻辑运算如XOR，NOT，ADD，SUB，ROR，ROL，就能得到几百种编码shellcode的方法，而这些经过编码的shellcode更是能产生无限可能的shellcode运行方式，杀毒软件在解码序列之前检测到shellcode的概率很低，不过自从杀软开发出了启发式引擎以后，就能够检测到shellcode的解密循环过程。目前，安全测试人员在编写shellcode编码器时，还没有能够找到用于绕过用于检测解码循环的静态方法的有效方式。 干扰寄存器的办法在x86架构中，所有寄存器都有特定的用途，例如ECX代表扩展计数器寄存器，它通常用作循环计数器，当我们在任何编译语言中编写一个基本循环条件时，编译器可能使用ECX寄存器作为循环计数器变量，这样代码块内连续增加的ECX寄存器就很容易触发杀毒软件的启发式引擎检测机制，解决这个问题的方法很简单，不把ECX寄存器用作循环计数器，但是这个办法对于所有的其它类型的代码片段（如函数epilogue/prologue等）也非常有效。由于很多代码识别机制取决于寄存器使用，所以我们可以通过干扰寄存器的办法来降低编写汇编代码时被检测到的风险。 垃圾混淆代码目前几乎每个杀毒软件都有办法来识别代码块内的解码器，据我们统计，大概有可能有几百种方法。但不管是哪种方法，最终都要生成用于静态地检查的代码块签名，所以为了避免被检测到，我们可以使用解码器代码内部的随机NOP指令来绕过静态签名分析，不过不一定非要使用NOP指令，可以是任何保持原始代码功能的指令，其目的最终是向代码块总添加垃圾指令，以打破代码块内的恶意签名，不过也要注意垃圾指令的大小，因为过多的垃圾混淆代码会让恶意程序的信息熵变大。 NOP指令的代码如下： 从上图可以看出，唯一的改变在于EAX和ECX寄存器，由于在垃圾混淆代码时，负责对shellcode索引计数的寄存器是EAX，并且在每个XOR和MOV指令之间都会插入一些NOP填充，由于我们测试时使用的是 “windows/meterpreter/reverse_tcp ”命令，所以在加密之后shellcode有一个10字节长的随机XOR密钥，这些都会存放在解码器内，使用nasm -f bin Decoder.asm命令将解码器汇编成二进制格式（不要忘了移除shellcode中的换行符，否则nasm不能执行汇编命令）。 下面是杀毒软件对编码前的shellcode扫描的结果， 不出所料，大量的杀软扫描器能检测到编码之前的shellcode。让我们再来看看编码后的扫描结果， 巧妙利用杀软的缓解技术虽然可以用很多办法实现免杀，但杀软的防范漏洞缓解技术却将免杀的技术推向了一个全新的水平。微软在2009年发布了增强缓解体验工具包（EMET），EME是加固Windows防止恶意程序利用操作系统或软件安全漏洞的最有效方法之一，它有几个保护机制， 12345678910111213动态数据执行保护（DEP）结构异常处理程序覆盖保护（SEHOP）NullPage分配堆喷射保护导出地址表地址过滤（EAF）强制ASLR导出地址表访问过滤（EAF +）ROP缓解措施加载库检查内存保护检查调用者检查堆栈翻转（Stack pivot）Attack Surface Reduction（ASR） 在这些缓解中，EAF，EAF +和调用者检查是我们最关注的三种技术，如前所述，metasploit框架中几乎所有的shellcode都使用Stephen Fewer的Hash API，并且由于Hash API应用了PEB 及EAT解析技术，EMET可以轻松检测和阻止shellcodes的运行 。 绕过EMET调用者检查可以检测到EMET内发生的Windows API调用，并阻止Win API函数中的RET和 JMP指令，以便阻止所有ROP方式的漏洞利用，在HASH API中，在找到需要的API函数地址后，会使用JMP指令执行函数，但这会触发EMET的调用者检查，所以为了绕过调用者检查，应该避免使用指向Win API函数的JMP和RET指令，我们要用CALL指令替换JMP指令来指向Win API函数，从理论上讲Hash API应该能绕过调用者检查，但是当我们查看EAF及EAF+缓解机制时，Hash API却使用被调用的代码阻止程序访问导出地址表（EAT），并且还会检查堆栈寄存器是否在允许的边界内，或者尝试检测特定代码块的MZ / PE报头和KERNELBASE，这是一种非常有效的用于防止EAT解析技术的方法，但EATEAT不是唯一一个包含函数地址的结构，由于导入地址表（IAT）也保存有应用程序使用的Win API函数地址，如果恶意应用程序获取了所需的函数，则可以收集IAT结构内的函数地址。一个名为Joshua Pitts的网络安全研究员最近开发了一种新的IAT解析方法，即在导入地址表中获取LoadLibraryA和GetProcAddress Windows API函数，在获取这些函数地址后，可以从任何库中提取任何函数。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Bypass-AV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免杀的艺术(二)]]></title>
    <url>%2F2019%2F10%2F16%2F%E5%85%8D%E6%9D%80%E7%9A%84%E8%89%BA%E6%9C%AF(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[免杀的艺术(一) 免杀的艺术(二) 免杀的艺术(三) 免杀的艺术(二)在上一篇《免杀的艺术 1》中，我们详细列举了各种实现免杀的技术。 今天，我们将继续为大家进行免杀的话题——PE文件后门的植入， 不过还是和上一篇一样，我们建议读者需要了解x86程序集，调试器和PE文件的基本知识。 现在几乎所有的安全研究人员，安全测试人员和恶意软件分析人员每天都要处理各种各样与后门攻击相关的工作，原因很简单，将后门放置到在系统中插入后门或在程序中保留随意访问的权限是当下最流行的一种攻击方式。 鉴于此，本文会主要为大家介绍往32位PE文件中植入后门的方法，但由于PE文件是微软在Unix平台的COFF(Common Object File Format 通用对象文集格式)的基础上制成的。所以凡是适用于COFF格式下可执行二进制文件的后门植入方法，都适用于32位PE文件，另外，由于保持后门的隐蔽性对于恶意软件的隐藏至关重要，所以本文将会像第一篇一样列举各种实现32位PE文件后门的免杀技术。 专业术语和第一篇一样，我们先来对一些专业术语做一些介绍： 红队渗透测试：渗透测试是正义黑客大展身手的地方。他们可以对漏洞评估中识别出的许多漏洞进行测试，以量化该漏洞带来的实际威胁和风险。这群人我们通常称为“白帽黑客”。 地址空间布局随机化（ASLR）：是参与保护缓冲区溢出问题的一个计算机安全技术，为了防止攻击者可靠地跳转到内存中的特定的被利用函数中，ASLR会对进程的关键数据区域的地址空间位置进行随机布置，其中包括可执行的部分、堆、栈及共享库的位置。 代码洞：代码洞是由另一个程序写入其他进程内存中的一段代码。这些代码可以通过在目标进程内创建远程线程来执行。代码的代码洞通常是对代码脚本函数的其中一部分进行引用，该脚本函数具有注入自定义指令的能力。例如，如果脚本的内存有5个字节的容量，可是目前实际只使用3个字节的容量，则剩余的2个字节的容量就可以用来添加外部代码。 校验和：是指传输位数的累加，当传输结束时，接收者可以根据这个数值判断是否接到了所有的数据。如果数值匹配，那么说明传送已经完成。通过这种方法可以检验文件运行的完整性，但校验和并不会去验证这个完整数据本身的真实性。 实现PE文件后门植入的方法本文中所有的实现技术都是基于开源SSH的putty工具来可执行的。选择putty工具来植入后门有很多原因，其中之一便是putty工具能支持多个数据库而且能实现Windows API的本地C ++项目，而选择开源SSH的访问协议能让我们在植入后门时更加隐蔽，不容易被检测到。 我们所使用的后门代码是来自metasploit项目中的常用命令 “windows/meterpreter/reverse_tcp ”，因为该命令不仅能将meterpreter shellcode注入到目标PE文件中，同时还能保持程序的正常运行。另外，注入的shellcode会选择在一个新的线程上开始运行，然后在伺机和正常运行的程序产生连接关系。之所以要选择新的线程，就是为了避免被杀软产品发现。 在PE文件中植入后门大致包含4大部分： 12341．找到后门代码的可用空间2．截获程序流程3．注入后门代码4．恢复程序流程 而怎样具体执行这4大部分，才是成功植入后门的关键。 代码可用空间的实现如何在PE文件中选择合适的空间来插入后门代码使我们实现后门的关键一步， 解决空间问题的两种主要方法： 1.增加新空间这种方法的好处显而易见，就是新增加的这部分空间是根据新增加的后门代码的多少来变化，没有空间限制，但缺点也很明显，由于空间被修改的痕迹太过明显，所以很容易被检测到。 使用一个汇编程序或PE编辑器（如LordPE），我们可以为所有的PE文件扩充一个区段头，比如借助LordPE，就可以在本文所使用的putty工具的区块表中，扩充一个1000字节大小的区段。 当新扩充一个区段时，要将段标志设置为“Read/Write/Execute”， 当运行后门shellcode时，这个设置对于PE映像映射到内存至关重要。 在扩充完区段头之后，我们还要来继续来调整整个PE文件大小，这可以使用十六进制编辑器中，在PE文件的段尾来添加对应的空字节来实现。 至此，PE文件中新的空间就算添加完成了。然后来试着运行以下该文件，如果运行正常，我们就可以通过调试器来修改新增加的这个区段了。 不过目前几乎所有的杀毒软件都能识别出“Read/Write/Execute”这样的异常代码， 即使添加的空间不会被赋予什么运行权限，也会被检测到。 2.利用代码洞解决代码可用空间问题的第二种方法便是使用目标可执行文件中的代码洞。几乎所有编译的二进制文件都有代码洞，我们可以利用这些即有的代码洞实现后门植入。由于这种方法利用的是现有的空间，即便在植入后门以后，整个PE文件的大也不会改变。不过该方法也有很多缺点， 比如由于代码洞的数量和大小会因文件而异，所以可用空间也会受限于文件的代码洞，这也就决定了当我们要植入后门代码时，应尽可能地精简这些代码。另一个缺点是当恶意应用程序在代码洞里的空间进行恶意运行时，其执行必须重新定向到代码洞所在地址，而且所有位于代码洞的代码还要被赋予“execute”权限，甚至连一些以自修改的方式编码或混淆的shellcode也需要“write”权限才能进行代码更改。 不过有一种办法可以解决代码洞的空间限制约束，就是同时使用多个代码洞，同时还可以把植入的后门代码分割为几部分，降低被检测到的风险，不过这样平白无故的对区段进行权限分割反而会引起杀软的注意。 目前只有很少的高级方法才能做到即能够修改运行时的内存权限又能避免直接更改区段权限，由于这些方法需要定制的shellcode，编码和IAT解析技术，所以我们会把它列为下一篇的分析重点，请大家继续关注。 借助于Cminer工具，我们可以很容易找到这些PE二进制文件的所有代码洞，例如，通过命令./Cminer putty.exe 300，我们可以找到putty.exe中所有长度大于300字节的代码洞， 可以看出，我们找到了5个符合条件的代码洞，起始地址是代码洞的虚拟内存地址（VMA），当PE文件加载到内存中时，文件偏移量是以字节为单位的PE文件内的代码洞的位置地址。 从上图可以看出，大部分代码洞的位置都分布在这些区段内，但由于这些区段代码都没有“execute”权限，所以我们还做一些权限修改。由于我们所测试的后门代码在400到500字节左右，所以这5个代码洞都足够用了。另外代码洞的起始地址要进行保存，在将这段代码的权限更改为“Read/Write/Execute”之后，我们寻找代码可用空间的这一步就算完成了。接下来，我们就要解决程序执行流的重定向问题了。 截获程序流程我们在这一步中，要实现的是通过修改来自目标可执行文件的指令将执行流重定向到后门代码。不过请大家注意，由于所有二进制指令都具有大小的（以字节为单位），而我们为了跳转到后门代码地址，将使用5-6个字节的长跳跃。因此，在修改二进制文件的指令时，这个指令的大小必须与长跳转的字节大小相同，否则指令将会失败。 选择合适的空间来重定向绕过杀软产品的动态检测和沙箱分析机制是非常重要的。如果直接进行重定向，则可能在杀软的动态分析阶段就暴露了。 隐藏在用户交互下： 绕过沙盒和动态分析最重要一点就是要延迟shellcode的运行时间和避免shellcode触发沙箱的检测机制。但是植入后门时，我们是没有这么多的空间来在PE文件中添加这些免杀代码的。 由于使用汇编语言设计防检测机制所耗费的成本过大，所以我们使用了隐藏在用户交互下这个方法，这个方法可以很方便的实现后门免杀的功能。由于该方法在重定向时，必须要求用户亲自开启流程的重定向才能激活后门功能。所以如果这个方法可以正确实现，那免杀将100％的实现，且这种办法还不会增加后门代码的大小。 如下图所示，我们选择了putty上的“Open”，检查给定的IP地址的有效性， 如果IP地址字段值不为空并且有效，则putty就会启动连接给定IP地址的连接功能。 如果客户端成功创建了SSH会话，就会弹出一个新窗口并请求用户输入登录凭据， 此时，程序流便开始了重定向，这么做免杀的概率很高，因为目前还没有杀毒软件能够检测到如此复杂过程，所以，我们编写的恶意软件就不必担心进入到沙箱或被动态分析了。 使用基本的逆向工程方法，如下面使用的字符串及字符串的引用，将不难找到要连接IP的地址。在建立连接后，会在窗口出现了一个字符串“login as：”。这个字符串将帮助我们找到连接IP的地址，建议大家使用交互式反汇编器（IDA Pro）。 在交互式反汇编器中选择Views-&gt;Open Subviews-&gt;Strings，来寻找 “login as:” 字符串 找到“login as:” 后双击，就能跳出其所在的位置，由于在交互式反汇编器中可以显示出数据节内所有对“login as:” 的交叉引用，按“Ctrl + X”，就能显示出所有交叉引用， 这些交叉引用会显示在“login as：”字符串的函数内部， 这时我们的修改指令就完成了，不过要将这个修改好的指令保存，因为在后面我们还要继续用到。 通过将PUSH 467C7C指令更改为JMP 0x47A478，后门的重新定向过程就完成了。不够需要注意的是，要记住JMP 0x47A478的地址，在注入后门代码完成后，我们还要把JMP 0x47A478的地址作为返回地址，接下来就该谈谈怎样注入后门代码了。 注入后门代码在注入后门代码时，我们认为首先需要做的是在注入后门代码 之前保存寄存器，因为所有寄存器中的每个值对于程序的执行是非常重要的。通过将PUSHAD和PUSHFD指令置于代码洞的开头部分，所有寄存器和寄存器标志就都存储在堆栈中了。这些值将在注入后门代码之后弹出，以便程序可以继续正常运行。 我们已经在前面提到过，我们所使用的后门代码是来自metasploit项目中的常用命令 “windows/meterpreter/reverse_tcp ”，但在注入shellcode时，我们还应该再做些许修改。一般情况下，“windows/meterpreter/reverse_tcp ” 尝试连接到处理程序会有一个给定的次数，如果超过这个次数连接就会失败，程序也会调用ExitProcess API关闭“windows/meterpreter/reverse_tcp ”命令。 如果连接失败，putty客户端就将停止运行，所以我们要改变几行shellcode，来重新尝试连接，另外，shellcode的大小也能减少 在汇编代码中进行必要的更改后，使用nasm -f bin stager_reverse_tcp_nx.asm命令进行编译。现在“windows/meterpreter/reverse_tcp ”命令已经可以使用了，但是它不会被直接放置在代码中。我们的目标是在新线程上运行shellcode。为了创建一个新的线程，我们需要用另一个shellcode来让CreateThread API调用“windows/meterpreter/reverse_tcp ”命令。 将如上所述的十六进制的createthread.asm文件中的shellcode字节放置在代码后，就可以使用nasm -f bin createthread.asm命令进行汇编了。现在就可以将shellcode植入代码洞了，但在植入shellcode之前，我们应该先对它编码，这样它才能绕过杀软的静态及特征分析。因为目前几乎所有的杀软产品都能检测到metasploit项目中的几乎所有编码器，所以强烈建议使用自定义编码器。至于如何自定义编码器我们将会在另一篇文章中讲解，本文中将使用多个metasploit编码器组合的办法来实现免杀的功能。在每次组合之后，我们会将原始格式的shellcode上传到相应的在线查毒网站，看看免杀效果如何。尝试各种组合，直到把它检测到风险降到最低为止。 在正确编码shellcode之后，我们就可以把它插入代码洞了。选择PUSHFD下的指令，然后在immunity debugger中按Ctrl + E组合键，shellcode就将以十六进制格式粘贴过来。 使用xxd -ps createthread命令，创建线程后的shellcode就会以十六进制格式显示出来，或使用十六进制编辑器打开shellcode并复制十六进制值。将十六进制值粘贴到调试器时，请注意字节限制，由于这些修改都是在immunity debugger中进行的，而对于immunity debugger来说，向编辑代码窗口中粘贴代码时，是有字节限制的。它不会粘贴所有的shellcode，所以，我们每次粘贴时都会剩余最后2个字节，所以我们要多粘贴几次，直到把所有的shellcode复制完。这时，插入后门代码就全部实现了。 恢复程序流程在创建玩后门代码线程之后，程序需要返回到正常运行的流程中，这意味着EIP寄存器（它可存储着我们cpu要读取指令的地址）应该返回到重定向之前的状态。但在返回之前，我们应该找到所有保存在寄存器中地址。 我们可以在shellcode结尾处输入POPFD和POPAD命令，将所有保存在寄存器中的地址从堆栈中找出。在检索完寄存器后，大家一定要记得处理被截获的指令。不过在重定向到代码洞时，我们已经将PUSH 467C7C指令替换为了JMP 0x47A478，所以要输入PUSH 467C7C指令，才能在寄存器中检索出被截获的指令。 在返回之后，我们可以通过插入JMP 0x41CB73指令重定向到代码洞，代码如下所示。 最后选择所有修改和插入的指令，把它们复制到可执行文件。当所有指令被复制并保存到文件后，关闭调试器并测试可执行文件，如果可执行文件运行顺畅，则证明后门可以使用。 最后，建议固定最终文件校验和，以保持文件的真实性，而不是看起来可疑，这也可能对降低检测分数有影响。 最后，建议处理好最终文件的校验和，以保持文件的真实性，以免被杀毒软件检测出来。 总结如果大家完全按照以上的方法进行编写，我们可以保证产生的后门是完全不可检测的。为了保证免杀，本文还将列出一些针对这些后门技术的应对之策，这些措施可以有助于系统管理员，恶意软件记录器和杀毒软件产品的开发人员。 1.部分权限控制如果涉及到backdoored文件时，部分权限控制对于检测异常程序非常重要，因为编译器永远不会设置代码的全部权限，特别是像“.data”或“.rdata”这样的数据段更不应该有执行权限，而类似的.text的代码段也不应该被赋予编写权限，如果发生了异常，则应该就是恶意程序了。 2.不常见的字段识别如果程序员不进行任何配置，就在编译器创建5-6通用类型的段，则目前几乎所有的杀毒软件都应该能识别这种不常见和可疑的字段。 3.签名检查签名检查属于非常经典的杀软技术，但它也是最有效的，当大家下载一个新的程序或任何一个可执行文件时，签名检查便会开始检测。 4.检查文件校验和当植入后门程序的校验和值与文件的实际校验和之间存在差异时，就代表程序已经被修改了。 附件: Linux系统下运行 Cminer 目标程序 代码洞大小 Cminer]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Bypass-AV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免杀的艺术(一)]]></title>
    <url>%2F2019%2F10%2F16%2F%E5%85%8D%E6%9D%80%E7%9A%84%E8%89%BA%E6%9C%AF(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[免杀的艺术(一) 免杀的艺术(二) 免杀的艺术(三) 免杀的艺术(一)从本文开始，我们将分三章来系统的讲述一下有关免杀的各种技术。 虽然目前有很多方法可以让恶意软件使用某一技术绕过反病毒检测，但这些显然不是恶意软件免杀的终极目标， 它们的最终目标是实现 “FUD”， “FUD” 是地下网络论坛的黑话，代表“恶意软件完全不可被检测到”的意思。 本文主要是通过介绍静态免杀、动态免杀和启发式免杀三种方法来实现“FUD”，但不管是哪种实现的技术，其中的一个关键点就是恶意软件的大小一定要足够小。另外，本文还会向大家介绍杀软和Windows操作系统的内部工作原理。 建议读者应该具备一定的C/C++、汇编和PE文件结构的相关知识，否则本文将晦涩难懂。 反杀软检测技术介绍应该说每一类型的恶意软件所实施的反检测技术都是不一样的（恶意软件可以分为病毒、木马、僵尸程序、流氓软件、勒索软件、广告程序等），虽然本文会对所有相关的反检测技术都进行介绍，但我们还是会将注意力放在stager阶段的meterpreter这种有效载荷的工具上，因为几乎所有的恶意软件的攻击命令的执行都必须依靠 meterpreter来实施攻击，例如: 提权、凭证窃取、进程迁移、注册表操作和分配更多的后续攻击， 另外，MetasploitFramework是一个缓冲区溢出测试使用的辅助工具，也可以说是一个漏洞利用和测试平台，它集成了各种平台上常见的溢出漏洞和流行的shellcode，并且不断更新，使得缓冲区溢出测试变的方便和简单。 专业术语1.基于签名的检测：传统的防病毒软件很大程度上依赖于签名来识别恶意软件。工作原理如下： 当恶意软件被杀软公司采集后，杀软后台的研究人员以及动态分析系统便会对这些样本进行分析，一旦确定是恶意软件，后台便会提取恶意文件的标签并将其添加到反病毒软件的签名数据库中。 2. 静态程序分析：静态程序分析是在不实际运行程序的情况下进行的分析。 大部份的静态程序分析的对象是针对特定版本的源代码，也有些静态程序分析的对象是目标代码。 3. 动态程序分析：动态程序分析是通过在真实或虚拟处理器上执行程序而执行的分析。为了使动态程序分析真实可信，我们必须要能够对各种目标程序的行为进行测试。 4.沙盒分析技术：沙盒是一个观察计算机病毒的重要环境，用于为一些来源不可信、具备破坏力或无法判定程序意图的程序提供试验环境。 5.启发式分析：启发式分析是许多计算机防病毒软件使用的一种方法，其被设计用于检测未知的计算机病毒，以及新的病毒变体。 启发式分析是基于专家的分析，利用它可以对已知或未知的恶意软件进行各种维度的风险衡量，其中多标准分析（MCA）是其中的方法之一，不过启发式分析不是统计分析而是基于可用的数据或统计。 6.信息熵检测每个恶意软件都可以被描述成数值性质的属性(例如:信息熵)或者抽象性质的属性，信息熵就是通过找到最合适的量度来验证并且对比恶意软件的属性。 7.其他常见检测技术7.1 混淆检测： 病毒由两个部分组成：载荷（payload）和混淆部件（obfuscator），载荷是用来做坏事的代码，而混淆部件则是病毒用来保护自身免于被查杀的，通常恶意软件开发者都会将其代码进行混淆以降低其代码的可读性 所以混淆检测就非常的有针对性。 7.2 加壳检测： 恶意软件一般都会被压缩加壳，因为加壳会将可执行文件进行压缩打包, 并将压缩数据与解压缩代码组合成单个可执行文件的一种手段。 当执行被压缩过的可执行文件时，解压缩代码会在执行之前从压缩数据中重新创建原始代码。所以检测恶意软件是否使用了加壳技术，也是发现的一种重要手段。 7.3 加密检测： 恶意软件使用加密对其二进制程序进行加密，以免被逆向分析。加密存在于恶意软件的构建器和存根中，当恶意软件需要解密时，不会用恶意代码常用的正常方法执行它。为了隐藏进程，恶意软件使用了一个有名的RunPE的技术，代码会以挂起的方式执行一个干净的进程（比如iexplorer.exe或者explorer.exe），然后把内存内容修改成恶意代码后再执行。所以检测RunPE的运行，就可以很容易的检测到恶意软件了。 加密与加壳检测技术的深度分析由于目前杀毒软件的检测技术也来越高，不仅能对恶意软件签名和攻击行为分析，还能够对使用的加密与加壳技术进行探测。由于对加密与加壳的检测相对容易，所以目前杀软公司都侧重于对加密与加壳行为进行检测，但凡出现这些可疑行为，例如，PE文件在内存进行加密和解密加载时，都会进行深入分析。 为了完全理解PE映像的内存执行过程，我们先要了解一下Windows是如何加载PE文件的。一般在编译PE文件时，编译器会将主模块的地址设置为0x00400000，而编译过程中所有的地址指针和长跳转指令地址都是依据主模块的地址来计算，在编译过程结束时，编译器会在 PE 文件中创建一个重定位分区表，重定位PE文件所有的地址指针和长跳转指令地址。 在执行PE映像时，Windows会检查PE文件要映射到的进程地址空间是否可用，如果空间不可用，则Windows会会在启动之前将PE映像加载到内存上的绝对地址，再利用重定位分区表修正所有地址。 所有这种机制称为 “地址空间布局随机化(ASLR) ”。 为了在内存密码器上执行PE映像，需要对PE文件头进行解析并重定位绝对地址，如果出现模拟系统加载器这种可疑的行为就证明该运行很可能是恶意运行。在我们对所有使用C 语言或更高级语言编写的加密程序进行分析时，总能看到“NtUnmapViewOfSection”和“ZwUnmapViewOfSection”这样的Windows API函数，这些函数会简单地从主体进程的虚拟地址空间中取消映射视图， 以上这个操作过程就是RunPE，几乎90%的加密都会使用到这一技术。 当然杀软产品不能仅仅根据是否使用了Windows API 函数就判断该程序是恶意的，但是可以根据该函数的使用顺序来提高检测的准确率。 鉴于杀软产品已经开始对加密与加壳技术进行探测，目前已有一部分恶意软件的开发者在使用密码器进行汇编时，不使用这些Windows API 函数和手动执行重定位，因为他们知道，没有哪一个正常的程序会刻意的进行模仿系统的加载。 另外由于在不断加载的过程中，恶意软件会产生很多文件，而这些文件所自带的信息熵增加到一定程度时，就会被杀软产品标记为可疑行为进而进行持续的分析。 完美的免杀方法到目前为止，要实现恶意软件的“FUD”，加密恶意代码被认为是个不错的选择，不过有几点要注意： 1.恶意程序在解密时，应当也进行代码混淆 2.当恶意文件在内存中运行解密代码时，我们必须要保证在不重定位绝对地址的情况下进行 3.恶意软件是否在沙箱环境中运行，如果是，则立马停止恶意文件的解密 4.应当只对 PE 文件中的 shellcode 或 只有二进制文件的.text部分进行加密，而不是对整个 PE 文件进行，以便把信息熵和降到最低 以下是恶意软件流程图。 我们的“杀软检测”功能将检测恶意软件是否正在沙箱中被动态分析，如果功能检测到AV扫描器的任何迹象，则它将再次调用主函数或者仅当 “AV Detect” 函数来用。如果没有发现AV扫描器的任何迹象，它会调用 “解密Shellcode” 的功能。 以下就是 meterpreter 反汇编 shellcode 的原始格式。 以下就是 meterpreter 反汇编 shellcode 的原始格式。 为了让信息熵保持适当的大小，我们需要将shellcode注入方法改为使用多字节键的xor加密，xor加密标准不同于RC4或blowfish。因为恶意软件根本就用不到像RC4或blowfish这样的强加密，所以杀软产品也不会企图去解密信息熵中的shellcode，因此我们在编写恶意软件时，只需保证shellcode具备不可读和不可检测的静态字符串就足够了，如果使用xor，那解密过程更快，加密库中的代码量也会少很多。 同一个 meterpreter 代码使用 XOR 加密的前后对比 启发式引擎启发式引擎是基于统计和规则的分析机制。他们主要的目的是检测事先未知的病毒，同时根据预定义的标准给出威胁等级，甚至当一个正常运行的程序超出其威胁等级时，也会被认定为恶意软件。 由于启发式引擎是杀软产品中最核心的部分，每个公司都会基于自己不同的判断规则和行为分析，因此没有正式的威胁等级标准让我们参考，所以我们只能自行总结出常见的一些判断标准，来供大家参考： 1234567891011121314151617181920212223242526272829循环解密行为读取运行设备名称读取加密器的 GUID连接随机域名读取 Windows 安装日期删除可执行文件在二进制文件内存中搜索可用的IP地址修改代理设置在运行的进程中安装HOOKS或PATCHES往浏览器中注入代码注入远程进程查询进程信息设置过程错误模式以覆盖错误窗口异常熵的出现检测杀软的存在对特定的注册表项的变动情况进行监控包含提权的能力修改软件的相关限制策略读取系统/视频 BIOS 版本PE文件头中的结束字节异常创建受保护的内存区域创建大量进程企图进行长时间休眠不常用的字节读取 Windows产品ID包含循环解密包含启动或操作设备的驱动程序的能力包含阻止用户进行干扰的能力…… 所以，当我们在编写免杀的恶意软件和解密shellcode模块时，一定要避免上面这些坑。 解密Shellcode混淆解密机制是实现免杀的另一个重要手段，由于PE文件内部的解密循环能够被启发式引擎检测到，目前大部分杀软已经针对这个解密过程进行了针对性的检测。比如，一些扫描器会等到ECX寄存器为0时，再分析解密后的内容。 下面是解密shellcode的代码。 可以看出，这是用一个for循环来完成的xor操作，而xor操作的前后汇编代码块只是一些进行一些随机的xor操作和跳转。这些对于混淆解密机制来说已经足够了。 调试模式动态分析检测： 另外在编写沙盒检测机制的时候我们也需要混淆编写函数，如果我们所使用的反汇编方法被启发式引擎检测到了，那就算免杀目的失败。 第一种检测机制是检查我们所编写的恶意进程是否被调试。 用Windows用户态调试器来确定调用过程是否正在由用户模式调试器调试，但是我们不会用这个方法进行编写， 因为大部分杀软都会监控对用户态调试进行监控。 我们可以通过PEB结构中的“BeingDebuged”字段来判断。 这些内联汇编中的代码指向地都是 PEB结构中的 “BeingDebuged”字段的指针，如果调试器存在，它将再次检查，直到堆栈中发生溢出，当溢出发生时，堆栈保护(stack canaries)将触发异常并且关闭进程， 这是退出程序的最快方法。 虽然可以手动检查“BeingDebuged”字段可以绕过大量的杀软，但是还是有一些杀软能够对这种情况进行检测，因此我们需要混淆上述代码，以避免杀软进行静态字符串分析。 请注意我们会在所有混淆操作之后都添加一些跳转指令，避免被检测到，不过这不会影响免杀的实现。 加载虚拟dll库：如果我们尝试加载虚拟dll，正常情况下，返回值是NULL，一些杀软的动态分析机制就会利用这个返回值来进一步观察程序的运行情况。以便做出更准确的判断。 获取Tick Count(毫秒计时器)值的检测：在这种方法中我们将利用 杀软产品的时间截止日期。 在大多数情况下，杀软 产品都被设计为用户友好型，为了不影响用户的其他操作，杀软 产品用来扫描文件的时间都很短。最初恶意软件开发人员会使用 “sleep()” 函数来避开这种快速的扫描，然后等扫描过后，再开始运行。但现在这个杀软漏洞已经被堵死了，因为所有杀软 产品都会跳过 sleep 功能。 为了能够继续使用这个漏洞，我们将使用 “GetThickCount()” 的 Windows API 函数，我们使用它来获取从操作系统启动后经过的时间，然后尝试 sleep 1秒 sleep 后，通过比较两个 GetTickCout() 值来检查sleep 功能是否被跳过。如果时间差小于1秒，则被检测。 内核数检测:这个方法非常简单，就是检查系统的处理器核心数。因为杀软产品不会占用太多主机系统的资源。大部分沙盒系统只会分配1个处理器核心。 大内存分配：这个方法与刚刚的获取Tick Count值的道理是一样的，同样是利用杀软的扫描截止时间，简单的分配100Mb的内存，用0填充，最后释放。 我们会给所编写的恶意软件分配近 100 Mb 的内存，然后往其中添加一个 NULL 字节，然后再进行内存释放。 当程序内存在运行时增大到一定程度时，就会触发杀软结束扫描，以免在一个文件上消耗太多时间。 陷阱标志检测:陷阱标志用于跟踪恶意程序的，如果此标志被改动，则会触发每个指令产生“SINGLE_STEP” 异常。我们可以用下面的代码来对陷阱标志进行的跟踪属性进行禁用设置 互斥触发WinExec:这个方法在未来的免杀技术中，应该用途非常广。另外，它使用起来也非常简单，如下所示，我们会创建一个条件来判断互斥对象是否已经存在于系统上。 如果“CreateMutex”函数没有把已经存在的错误进行返回，我们将再次执行恶意程序，因为大部分杀软产品不会让正在分析的程序启动新进程和访问沙盒以外的文件。当出现错误运行时，恶意软件就可以开始执行解密了。 运行Shellcodes的正确姿势从windows vista开始，微软引入了数据执行保护或DEP的安全机制，来监控恶意程序。如果出现任何异常的运行，都将会触发DEP并通知用户关闭该程。这意味着我们不能把字节序列放入字符数组中执行，而是需要分配一块可读写可执行的内存。 微软实现内存分配的方式有很多种，大多数常见的恶意软件在字段中使用会使用“VirtualAlloc”函数，不过现在大多数杀软产品都会对其进行检测，我们建议还是使用其他内存操作函数。 下面是一些内存操作函数的用法： HeapCreate和 HeapAlloc：Windows允许创建可读写可执行的堆区域。 LoadLibrary和 GetProcAddress：LoadLibrary和GetProcAddress win api的函数组合不但允许我们使用所有其他的win api函数，而且这种组合又不直接调用内存分配函数。 GetModuleHandle 和GetProcAddress这个方法甚至不使用 LoadLibrary 函数，而是充分利用已经加载的kernel32.dll，GetModuleHandle能够从已经返回的dll中加载模块句柄，这个方法是运行shellcode最隐蔽的方式。 多线程：不管是对杀软产品还是对免杀程序来说，逆向分析多线程的PE文件都非常困难。多线程的方法不单单适用于 shellcode，还 可以用在上述所有的方法中。我们可以在执行 shellcode 的同时继续执行 “AV Detect” 功能 利用上述代码可以创建新线程并运行shellcode，只是在创建线程后有一个无限whlie循环来绕过杀软检测，可以说多线程方法是一种非常完美的免杀方法，既绕过了沙盒系统又绕过了动态分析，同时还能躲避启发式引擎的检测。 总结虽然本文已经列举了很多免杀的方法，但其实还有很多我们没有列举到，比如编译恶意程序时需要开启堆栈保护，降低文件大小可以加大逆向工程分析的难度，内联汇编的语法推荐用visual studio进行编译等。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Bypass-AV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ARP协议]]></title>
    <url>%2F2019%2F10%2F15%2FARP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[ARP简介 图解ARP1 一、ARP概述如果要在TCP/IP协议栈中选择一个“最不安全的协议”，那么我会毫不犹豫把票投给ARP协议。我们经常听到的这些术语，包括”网络扫描”、”内网渗透”、”中间人拦截”、”局域网流控”、”流量欺骗”，基本都跟ARP脱不了干系。大量的安全工具，例如大名鼎鼎的Cain、功能完备的Ettercap、操作傻瓜式的P2P终结者，底层都要基于ARP实现。 听上去这么”逆天”的协议，其实技术原理又简单的难以置信，例如ARP整个完整交互过程仅需要两个包，一问一答即可搞定！但是ARP协议也有它令初学者迷惑的地方，例如由它本身延伸出来的”代理ARP”、”免费ARP”、”翻转ARP”、”逆向ARP”，而这些不同种类的ARP，又应用于不同的场景。好吧，在深入到技术原理之前，作为初学者，我们先记住下面三句话： ①ARP（Address Resolution Protocol）即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。 ②在网络通信中，主机和主机通信的数据包需要依据OSI模型从上到下进行数据封装，当数据封装完整后，再向外发出。所以在局域网的通信中，不仅需要源目IP地址的封装，也需要源目MAC的封装。 ③一般情况下，上层应用程序更多关心IP地址而不关心MAC地址，所以需要通过ARP协议来获知目的主机的MAC地址，完成数据封装。 接下来，我们通过图解的方式来深入了解ARP协议是如何工作的。 二、ARP原理之请求应答同一个局域网里面，当PC1需要跟PC2进行通信时，此时PC1是如何处理的？ 根据OSI数据封装顺序，发送方会自顶向下（从应用层到物理层）封装数据，然后发送出去，这里以PC1 ping PC2的过程举例==&gt; PC1封装数据并且对外发送数据时，上图中出现了”failed”，即数据封装失败了，为什么？ 我们给PC1指令-“ping ip2”，这就告知了目的IP，此时PC1便有了通信需要的源目IP地址，但是PC1仍然没有通信需要的目的MAC地址。这就好比我们要寄一个快递，如果在快递单上仅仅写了收件人的姓名（IP），却没有写收件人的地址（MAC），那么这个快递就没法寄出，因为信息不完整。 那么，现在PC1已经有了PC2的IP地址信息，如何获取到PC2的MAC地址呢？此时，ARP协议就派上用场了。我们接着上面这张图，继续==&gt; 通过第三和第四步骤，我们看到PC1和PC2进行了一次ARP请求和回复过程，通过这个交互工程，PC1便具备了PC2的MAC地址信息。 接下来PC1会怎么做呢？在真正进行通信之前，PC1还会将PC2的MAC信息放入本地的【ARP缓存表】，表里面放置了IP和MAC地址的映射信息，例如 IP2&lt;-&gt;MAC2。接下来，PC1再次进行数据封装，正式进入PING通信，如下==&gt; 小结：经过上面6个步骤的处理，PC1终于把数据包发送出去了，之后便可以进行正常的通信了。看到了吧，ARP的功能和实现过程是如此的简单：它在发送方需要目标MAC地址的时及时出手，通过”一问一答”的方式获取到特定IP对应的MAC地址，然后存储到本地【ARP缓存表】，后续需要的话，就到这里查找。 既然是”缓存”表，意味着它有时效性，并且如果电脑或者通信设备重启的话，这张表就会清空；也就是说，如果下次需要通信，又需要进行ARP请求。在我们的windows/macos系统下，可以通过命令行”arp -a“查看具体信息=&gt; 三、ARP原理之广播请求单播回应上面的图解过程看上去简单又纯粹，好像我们就已经把这个协议的精髓全部get到，但其实，我们只是刚揭开了它的面纱，接下来我们才真正进入正题。例如，上面的图解过程中，整个局域网（LAN）只有PC1和PC2两个主机，所以这个一问一答过程非常的顺畅。 而实际网络中，这个LAN可能有几十上百的主机，那么请问，PC1如何将这个【ARP请求包】顺利的交给PC2，而PC2又如何顺利的把【ARP回应包】返回给PC1? 我们看下面的图： 为了营造出”几十上百”的效果，这里多添加了2个主机进来 ⁄(⁄ ⁄•⁄ω⁄•⁄ ⁄)⁄，并且增加了有线和无线的环境。那么，在多主机环境下，PC1现在发出的ARP请求包，怎么交到PC2手里？ 这时，ARP协议就需要采用以太网的”广播”功能：将请求包以广播的形式发送，交换机或WiFi设备（无线路由器）收到广播包时，会将此数据发给同一局域网的其他所有主机。 那么，什么是广播？对于初学者而言，我们只需要知道，大部分的广播包，它们有一个共同特征：二层封装时目的MAC是全f（ffff.ffff.ffff）或三层封装时目的IP是全1（255.255.255.255）。可以这样更方便的记住：目的地址最大的，就是广播。 注明：广播根据所在层次可分为二层广播和三层广播，根据发生范围可分为本地广播和定向广播，小伙伴们有兴趣可以自己再去拓展下。 接下来我们来看下这个ARP广播请求包接下来是如何工作的？ 根据上图我们看到，PC1发送的请求广播包同时被其他主机收到，然后PC3和PC4收到之后（发现不是问自己）则丢弃。而PC2收到之后，根据请求包里面的信息（有自己的IP地址），判断是给自己的，所以不会做丢弃动作，而是返回ARP回应包。 ARP请求是通过广播方式来实现的，那么，PC2返回ARP回应包，是否也需要通过广播来实现呢？答案是否定的。大部分网络协议在设计的时候，都需要保持极度克制，不需要的交互就砍掉，能合并的信息就合并，能不用广播就用单播，以此让带宽变得更多让网络变得更快。 那么，ARP回应包是如何处理的？这里需要特别关注ARP请求包的内容，在上面的图解里面，ARP请求包的完整信息是：我的IP地址是IP1，MAC地址是MAC1，请问谁是PC2，你的IP2对应的MAC地址是多少？ 简单来说，ARP请求首先有”自我介绍”，然后才是询问。这样的话，PC2在收到请求之后，就可以将PC1的IP和MAC映射信息存储在本地的【ARP缓存表】，既然知道PC1在哪里，就可以返回ARP单播回应包。 这张图我们需要得到两个信息：①被询问者PC2先生成了ARP映射信息，然后才是询问者PC1；②PC3和PC4等其他主机，无法收到这个ARP回应包，因为是单播形式。 小结：ARP协议通过”一问一答”实现交互，但是”问”和”答”都有讲究，”问”是通过广播形式实现，”答”是通过单播形式。 四、ARP数据包解读为了让大家更好的理解ARP协议以及广播和单播的概念，我们来看一下用Wireshark抓取到的真实网络中的ARP过程，通过数据包的方式来呈现，地址信息如下，部分MAC信息隐去。（建议初学者用GNS3配合Wireshark来抓取协议包进行分析，相比真实网络更加干净，方便分析） 主机1 &lt;—&gt; 主机2 主机1： IP1 10.1.20.64 MAC1：00:08:ca:xx:xx:xx 主机2： IP2 10.1.20.109 MAC2：44:6d:57:xx:xx:xx 【ARP请求包】 【ARP回应包】 【ARP协议字段解读】 Hardware type ：硬件类型，标识链路层协议 Protocol type： 协议类型，标识网络层协议 Hardware size ：硬件地址大小，标识MAC地址长度，这里是6个字节（48bti） Protocol size： 协议地址大小，标识IP地址长度，这里是4个字节（32bit） Opcode： 操作代码，标识ARP数据包类型，1表示请求，2表示回应 Sender MAC address ：发送者MAC Sender IP address ：发送者IP Target MAC address ：目标MAC，此处全0表示在请求 Target IP address： 目标IP 五、ARP到底是链路层还是网络层？这个问题的难度堪比另外一个世界级难题：世界上最好的编程语言是什么？ 其实早在20世纪时，W.Richard Stevens在《TCP/IP详解卷一》里面就提到了这个难题。这里给出我个人的协议分层思路，给大家作为参考=&gt; 协议到底所属哪一层，可以从应用/功能来考虑，也可以从层次/包封装来考虑。 以ARP协议为例，它的功能最终是获取到MAC信息，服务于链路层，从这点考虑，ARP是链路层协议；但是从层次来看，ARP基于Ethernet协议，IP协议基于Ethernet协议，它们在Ethernet协议里面有独立的Type类型，前者是0x0806，后者是0x0800，既然ARP和IP协议”平起平坐”，那么IP是网络层，ARP难道就不是网络层？ 小结：基于功能来考虑，ARP是链路层协议；基于分层/包封装来考虑，ARP是网络层协议。（此方法对于ICMP协议同样管用）]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>web-basic,protocol</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows系统中域和工作组的区别]]></title>
    <url>%2F2019%2F10%2F15%2FWindows%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%9F%9F%E5%92%8C%E5%B7%A5%E4%BD%9C%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Windows系统中域和工作组的区别,不过最新版Windows个人电脑一般都不会开这个共享网络了，所以基本办不到没有工作组，在公司个人电脑也都是在域中，有严格的审查，所以这个基础知识，知道就好,等有了后后边的知识，继续深入吧。 原文地址 原文 Windows系统中域和工作组的区别局域网（Local Area Network, LAN），又称内网，是指在某一区域内由多台计算机互联成的计算机组。 局域网可以实现文件管理、应用软件共享、打印机共享、扫描仪共享、工作组内的日程安排、电子邮件和传真通信服务等功能。局域网严格意义上是封闭型的。它可以由办公室内几台甚至上千台计算机组成。 局域网上的资源需要管理，“域”和“工作组”还有“家庭组”就是不同的网络资源管理模式。那么有何区别呢？ 一.工作组 Work Group在一个网络内，可能有成百上千台电脑，如果这些电脑不进行分组，都列在“网上邻居”内，可想而知会有多么乱。为了解决这一问题，早在Windows 9x/NT/2008就引用了“工作组”这个概念，将不同的电脑一般按功能分别列入不同的组中，如财务部的电脑都列入“财务部”工作组中，人事部的电脑都列入“人事部”工作组中。你要访问某个部门的资源，就在“网上邻居”里找到那个部门的工作组名，双击就可以看到那个部门的电脑了。 那么怎么加入工作组呢？其实很简单，你只需要右击你的Windows桌面上的“网上邻居”，在弹出的菜单出选择“属性”，点击“标识”，在“计算机名”一栏中添入你想好的名字，在“工作组”一栏中添入你想加入的工作组名称。 如果你输入的工作组名称以前没有，那么相当于新建一个工作组，当然只有你的电脑在里面。计算机名和工作组的长度不能超过15个英文字符，可以输入汉字，但是不能超过7个。“计算机说明”是附加信息，不填也可以，但是最好填上一些这台电脑主人的信息，如“技术部主管”等。单击[确定]按钮后，Windows 提示需要重新启动，按要求重新启动之后，再进入“网上邻居”，就可以看到你所在工作组的成员了。 一般来说，同一个工作组内部成员相互交换信息的频率最高，所以你一进入“网上邻居”，首先看到的是你所在工作组的成员。如果要访问其他工作组的成员，需要双击“整个网络”，就会看到网络上所有的工作组，双击工作组名称，就会看到里面的成员。 你也可以退出某个工作组，只要将工作组名称改动即可。不过这样在网上别人照样可以访问你的共享资源，只不过换了一个工作组而已。你可以随便加入同一网络上的任何工作组，也可以离开一个工作组。“工作组”就像一个自由加入和退出的俱乐部一样，它本身的作用仅仅是提供一个“房间”，以方便网上计算机共享资源的浏览。 二.域 Domain与工作组的“松散会员制”有所不同，“域”是一个相对严格的组织。“域”指的是服务器控制网络上的计算机能否加入的计算机组合。 实行严格的管理对网络安全是非常必要的。在对等网模式下，任何一台电脑只要接入网络，就可以访问共享资源，如共享ISDN上网等。尽管对等网络上的共享文件可以加访问密码，但是非常容易被破解。在由Windows 9x构成的对等网中，数据是非常不安全的。 在“域”模式下，至少有一台服务器负责每一台联入网络的电脑和用户的验证工作，相当于一个单位的门卫一样，称为“域控制器（Domain Controller，简写为DC）”。“域控制器”中包含了由这个域的账户、密码、属于这个域的计算机等信息构成的数据库。当电脑联入网络时，域控制器首先要鉴别这台电脑是否是属于这个域的，用户使用的登录账号是否存在、密码是否正确。如果以上信息不正确，域控制器就拒绝这个用户从这台电脑登录。不能登录，用户就不能访问服务器上有权限保护的资源，只能以对等网用户的方式访问Windows共享出来的资源，这样就一定程度上保护了网络上的资源。 一般情况下，域控制器集成了DNS服务，可以解析域内的计算机名称（基于TCP/IP），解决了工作组环境不同网段计算机不能使用计算机名互访的问题。 想把一台电脑加入域，仅仅使它和服务器在“网上邻居”能够相互看到是远远不够的，必须要由网络管理员进行把这台电脑加入域的相关操作。 1.域控制器的设置a.安装活动目录 使用命令dcpromo 安装活动目录/卸载活动目录 b.安装活动目录后的检查 更改本地连接DNS指向自己的IP地址 检查DNS上的SRV记录是否齐全？ 如果DNS上SRV如果没有自动注册成功，需要重新启动DC上netlogon服务 如果重新启动netlogon还是没有注册成功，检查DNS区域是否允许安全更新，本地连接是否允许在DNS中注册此连接的地址，域控制器的名称是否添加了域后缀。 2.将计算机加入到域a.更改DNS地址为域控制器的地址。 b.更改系统属性，计算机名/域 加入域后重启即可。 c.普通用户也可将计算机加入到域 d.可以先在活动目录指定的组织单元创建计算机帐号 再将计算机加入到域 三、域、工作组和家庭组的区别(官方解释)在工作组中： 所有的计算机都是对等的，没有计算机可以控制另一台计算机。 每台计算机都具有一组用户帐户。若要登录到工作组中的任何计算机，您必须具有该计算机上的帐户。 通常情况下，计算机的数量不超过二十台。 工作组不受密码保护。 所有的计算机必须在同一本地网络或子网中。 在家庭组中： 家庭网络中的计算机必须属于某个工作组，但它们也可以属于某个家庭组。使用家庭组，可轻松与家庭网络中的其他人共享图片、音乐、视频、文档和打印机。 家庭组受密码保护，但在将计算机添加到家庭组时，只需要键入一次密码即可。 在域中： 有一台或多台计算机为服务器。网络管理员使用服务器控制域中所有计算机的安全和权限。这使得更容易进行更改，因为更改会自动应用到所有的计算机。域用户在每次访问域时必须提供密码或其他凭据。 如果具有域上的用户帐户，您就可以登录到域中的任何计算机，而无需具有该计算机上的帐户。 由于网络管理员经常要确保计算机之间的一致性，所以，您也许只能对计算机的设置进行有限制地更改。 一个域中可以有几千台计算机。 计算机可以位于不同的本地网络中。 四、内网常用命令将Windows Server Core 加入到域netdom renamecomputer FileServer /newname:ProfileServer 更改计算机名称为ProfileServernetsh interface ipv4 set address name=”本地连接” source=static addr=192.168.10.212 mask= 255.255.255.0 gateway=192.168.10.1netsh interface ipv4 set dnsserver “本地连接” static 192.168.10.200 primarynetdom join %computername% /domain:http://ESS.COM /userd:administrator /passwordD:a1! /REBoot:5 net user ——&gt; 本机用户列表net localhroup administrators ——&gt; 本机管理员[通常含有域用户]net user /domain ——&gt; 查询域用户net group /domain ——&gt; 查询域里面的工作组net group “domain admins” /domain ——&gt; 查询域管理员用户组net localgroup administrators /domain ——&gt; 登录本机的域管理员net localgroup administrators workgroup\user001 /add —–&gt;域用户添加到本机net group “Domain controllers” ——-&gt; 查看域控制器(如果有多台)ipconfig /all ——&gt; 查询本机IP段，所在域等net view ——&gt; 查询同一域内机器列表net view /domain ——&gt; 查询域列表net view /domain:domainname —–&gt; 查看workgroup域中计算机列表]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web-basic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址和子网划分学习笔记之《超网合并详解》]]></title>
    <url>%2F2019%2F10%2F09%2FIP%E5%9C%B0%E5%9D%80%E5%92%8C%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E8%B6%85%E7%BD%91%E5%90%88%E5%B9%B6%E8%AF%A6%E8%A7%A3%E3%80%8B%2F</url>
    <content type="text"><![CDATA[知识结构:IP地址和子网划分学习笔记之《预备知识：进制计数》IP地址和子网划分学习笔记之《IP地址详解》IP地址和子网划分学习笔记之《子网掩码详解》IP地址和子网划分学习笔记之《子网划分详解》IP地址和子网划分学习笔记之《超网合并详解》 原文出处:https://blog.51cto.com/6930123/2115072 一、超网的概念超网(Supernetting)是与子网类似的概念，IP地址根据子网掩码被分为独立的网络地址和主机地址。超网，也称无类别域间路由选择（CIDR），它是集合多个同类互联网地址的一种方法。 与子网划分（把大网络分成若干小网络）相反，它是把一些小网络组合成一个大网络，就是超网。 二、超网合并网段1、合并网段示例：某企业有一个网段，该网段有200台主机，使用192.168.0.0 255.255.255.0网段。 后来计算机数量增加到400台，为后来增加的200台主机使用192.168.1.0 255.255.255.0网段，如下图：在路由器配置了192.168.0.1的IP地址接口，再添加192.168.1.1地址后，这样192.168.0.0和192.168.1.0这两个网段内的主机就通过路由器转发来实现通信了。那么有没有更好的办法，让这两个C类网段的计算机认为在一个网段？这就需要将192.168.0.0/24和192.168.1.0/24 两个C类网络合并。 网段合并：子网掩码向前移动1位，使得网络部分保持前部分相同。注：子网掩码往左移1位，能够合并2个连续的网段，但不是任何连续的网段都能合并。合并网段之后，如下图，这样所有主机相互通信就不再经过路由器转发了。 ①、合并之后网段为：192.168.0.0/23，IP分配如下图：②、合并之后IP地址192.168.0.255/23也是可以给计算机使用的，因为主机部分往左增加了一位0（并不是全1），如下图： 2、不是任何连续的网段都能合并示例，如下两个连续的网段是不能合并（往前移动1位，网络部分不能保持相同）的。如果非要合并，就要往前移动2位，这时候网络部分保持相同，这样一来，等于合并了4个网段，如下图： 3、哪些连续的网段能够合并（1）判断2个网段是否能够合并子网掩码往左移动相应位数后，网络部分保持相同才能合并。结论：判断连续的2个网段是否能够合并，只要第一个网络号能被2整除，就能够通过左移1位子网掩码合并。（2）判断4个网段是否能够合并结论：判断连续的4个网段是否能够合并，只要第一个网络号能被4整除，就能够通过左移2位子网掩码合并。 依次类推，要想判断连续的8个网段是否能够合并，只要第一个网络号能被8整除，这8个连续的网段就能够通过左移3位子网掩码合并。 4、网段合并的规律子网掩码左移1位能够将能够合并两个网段，左移2位，能够合并四个网段，左移3位，能够合并8个网段。 5、判断一个网段是超网还是子网①、通过左移子网掩码合并多个网段，右移子网掩码将一个网段划分成多个子网，使得IP地址打破了传统的A类、B类、C类的界限。 ②、判断一个网段到底是子网还是超网，就要看该网段是A类网络、还是B类网络、还是C类网络，默认A类子网掩码/8，B类子网掩码是/16，C类子网掩码是/24。 ③、如果该网段的子网掩码比默认子网掩码长，就是子网，如果该网段的子网掩码比默认子网掩码短，则是超网。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>basic-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址和子网划分学习笔记之《预备知识：进制计数》]]></title>
    <url>%2F2019%2F10%2F09%2FIP%E5%9C%B0%E5%9D%80%E5%92%8C%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E9%A2%84%E5%A4%87%E7%9F%A5%E8%AF%86%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%AE%A1%E6%95%B0%E3%80%8B%2F</url>
    <content type="text"><![CDATA[知识结构:IP地址和子网划分学习笔记之《预备知识：进制计数》IP地址和子网划分学习笔记之《IP地址详解》IP地址和子网划分学习笔记之《子网掩码详解》IP地址和子网划分学习笔记之《子网划分详解》IP地址和子网划分学习笔记之《超网合并详解》 原文出处:https://blog.51cto.com/6930123/2111068 一、序：IP地址和子网划分学习笔记开篇在我们的日常生活中，每个人的名字对应一个唯一的身（敏）份（感）证（词）号，在Internet上也是一样，每台主机(Host)，包括所有的具有上网功能的电子设备都有IP地址，有了IP地址，这些电子设备联网之后，才能正常通信。 要了解和熟练掌握IP地址和子网的划分，首先必须要对进制数计数有一定的认识，本篇为预备知识：掌握十进制、二进制、十六进制、八进制以及它们之间的关系和互相转换。 二、计算机中进制之间的关系和转换1、计算机中常见的进制我们的日常生活中常见的十进制，计算机的运行计算基础就是基于二进制来运行，可以简单的理解为：1代表通电（开），0代表断电（关），只是用二进制执行运算，用其他进制表现出来。十六进制常见于内存地址，注册表regedit，MAC地址等。 而计算机中八进制比较少见不常用，一般用于某些编程语言。 计算机本身使用的就是二进制，但是使用起来很不方便的，十六进制或八进制可以很好的解决这个问题（换算的时候1位十六进制数可以用4位二进制数代替，1位八进制数可以用3位二进制数代替）。因为进制越大，数的表达长度也就越短，例如：二进制数111111111111用十六进制表示为FFF，这样更简短，比较节省空间，方便读，也方便记。 2、十进制、二进制、十六进制、八进制之间对照表 3、二进制、八进制、十六进制数转换成十进制十进制可以有多位组成，根据十进制的运算规则：逢10进1，借1当10，从右向左依次为个位、十位、百位、千位、万位…（1024）10 = 1×10^3+0×10^2+2×10^1+4×10^0= 1000+0+20+4=（1024）10 由此类似，那么二进制的运算规则：逢2进1，借1当2，也可以由多位数组成，从右向左分别为1位、2位、4位、8位、16位…为什么称二进制的位数为1位、2位、4位…?这其实要从十进制的角度看二进制各位数得出的名称，如下表：从上表可以看出，当二进制产生进位时，代表的十进制数为2、4、8、16、32、64、128…二进制虽然只有0和1两个数字，但是由于数字所处的位置不同，表示的数据也不同例如：二进制数 “1101”这个二进制数共有4位，由3个1和1个0组成，比如数字1所处位置不同，所代表的大小也不同，其所处位置称作权。从右向左顺序各个位表示十进制的含义：第一个1表示：1的个数第二个0表示：2的个数第三个1表示：4的个数第四个1表示：8的个数(在此可以类比十进制1101，由1个1000，1个100，0个10，1个1组成。)所以，二进制数1101由1个8，1个4，0个2，1个1组成。按各位的权列出：（1101）2 = 1×2^3+1×2^2+0×2^1+1×2^0= 8+4+0+1=（13）10 这种权展开式可以很方便将二进制转换为十进制。同理，将八进制数1024转换为十进制数（1024）8 = 1×8^3+0×8^2+2×8^1+4×8^0= 512+0+16+4=（532）10 将十六进制数2B5F转换为十进制数（2B5F）16 = 2×16^3+B×16^2+5×16^1+F×16^0= 2×16^3+11×16^2+5×16^1+15×16^0= 8192+2816+80+15=（11103）10 由此我们可以得到一个非十进制数转换为十进制数的自定义公式：（X）Z = Xn-1×Z^n-1+ Xn-2×Z^n-2+…+ X1×Z^1+ X0×Z^0=（Y）10X表示一个非二进制（多位），Y表示一个十进制数（多位），Z表示各进制的基数，n表示位数。 4、十进制转换成二进制、十六进制、八进制十进制转换成二进制整数就通常采用“除2取余，逆序排列”的方法。具体做法是用2整除十进制整数，可以得到一个商和余数，再用2去除商，又会得到一个商和余数，如此反复，直到商为0停止。再把先得到的余数作为二进制低位有效位，后得到的余数作为二进制高位有效位，依次排列。举个示例：将十进制“11”转换为二进制 将十进制11转换为二进制数为1011，表示为：（11）10 =（1011）2同样的，十进制转换为十六进制，采用“除16取余，逆序排列”的方法，十进制转换为八进制采用“除8取余，逆序排列”的方法。 5、进制之间转换小技巧 1位十六进制等于4位二进制1位八进制等于3位二进制 由于十六进制和八进制的基数问题（太大或不太好算），它们的“幂次方”和“除基数取余”计算起来比较麻烦，为了方便计算，通常建议先把它们转换位二进制后再继续转换为相应的进制。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>basic-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Windows调试之反调试]]></title>
    <url>%2F2019%2F10%2F09%2FWindows%E8%B0%83%E8%AF%95%E4%B9%8B%E5%8F%8D%E8%B0%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Windows 调试中常见的反调试技巧技巧 文章参考houjingyi的文章架构，再次重新验证，并通过google，添加一些自己的东西，参考链接在后方。 一、探测Windows调试器恶意代码会使用多种技术探测调试器调试它的痕迹，其中包括使用Windows API、手动检测调试器人工痕迹的内存结构和查询调试器遗留在系统中的痕迹等。调试器探测是恶意代码最常用的反调试技术。 1 Windows API使用Windows API函数检测调试器是否存在是最简单的反调试技术。Windows操作系统中提供了这样一些API，应用程序可以通过调用这些API，来检测自己是否正在被调试。这些API中有些是专门用来检测调试器的存在的，而另外一些API是出于其他目的而设计的，但也可以被改造用来探测调试器的存在。其中很小部分API函数没有在微软官方文档显示。通常，防止恶意代码使用API进行反调试的最简单的办法是在恶意代码运行期间修改恶意代码，使其不能调用探测调试器的API函数，或者修改这些API函数的返回值，确保恶意代码执行合适的路径。与这些方法相比，较复杂的做法是挂钩这些函数，如使用rootkit技术。 1.1 IsDebuggerPresentIsDebuggerPresent查询进程环境块(PEB)中的IsDebugged标志。如果进程没有运行在调试器环境中，函数返回0；如果调试附加了进程，函数返回一个非零值 12345BOOL CheckDebug() &#123; return IsDebuggerPresent(); &#125; 我们调试32位64位在32位系统FS寄存器的偏移量30h处存在PEB（进程环境块），而在X64上，PEB（进程环境块）存在于GS段寄存器的偏移量60h处在其+2的偏移处存在标志BeingDebugged。读取其位置即可得到是否处于调试状态 1.2 CheckRemoteDebuggerPresent它不仅可以探测系统其他进程是否被调试，通过传递自身进程句柄还可以探测自身是否被调试。 123456BOOL CheckDebug() &#123; BOOL ret; CheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;ret); return ret; &#125; CheckRemoteDebuggerPresent实际上是通过NT(ZW)QueryInformationProcess进行反调试的，下一个讲。 1.3 NtQueryInformationProcess这个函数是Ntdll.dll中一个API，它用来提取一个给定进程的信息。它的第一个参数是进程句柄，第二个参数告诉我们它需要提取进程信息的类型。为第二个参数指定特定值并调用该函数，相关信息就会设置到第三个参数。第二个参数是一个枚举类型，其中与反调试有关的成员有ProcessBasicInformation（0）,ProcessDebugPort(0x7)、ProcessDebugObjectHandle(0x1E)和ProcessDebugFlags(0x1F)。例如将该参数置为ProcessDebugPort，如果进程正在被调试，则返回调试端口，否则返回0。这里0x1E和0x1F是未公开的标志位，详情https://ctf-wiki.github.io/ctf-wiki/reverse/windows/anti-debug/ntqueryinformationprocess-zh/ 123456789101112131415161718192021222324252627282930313233typedef NTSTATUS (*NtQueryInformationProcessPtr)( IN HANDLE ProcessHandle, IN int ProcessInformationClass, OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength, OUT PULONG ReturnLength);BOOL CheckDebug() &#123; int debugPort = 0; HMODULE hModule = LoadLibrary(&quot;Ntdll.dll&quot;); NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hModule, &quot;NtQueryInformationProcess&quot;); NtQueryInformationProcess(GetCurrentProcess(), 0x7, &amp;debugPort, sizeof(debugPort), NULL); return debugPort != 0; &#125; BOOL CheckDebug() &#123; HANDLE hdebugObject = NULL; HMODULE hModule = LoadLibrary(&quot;Ntdll.dll&quot;); NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hModule, &quot;NtQueryInformationProcess&quot;); NtQueryInformationProcess(GetCurrentProcess(), 0x1E, &amp;hdebugObject, sizeof(hdebugObject), NULL); return hdebugObject != NULL; &#125; BOOL CheckDebug() &#123; BOOL bdebugFlag = TRUE; HMODULE hModule = LoadLibrary(&quot;Ntdll.dll&quot;); NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(hModule, &quot;NtQueryInformationProcess&quot;); NtQueryInformationProcess(GetCurrentProcess(), 0x1F, &amp;bdebugFlag, sizeof(bdebugFlag), NULL); return bdebugFlag != TRUE; &#125; 接下来还有几种就不分开说了，一个Check例子概括NtQuerySytemInformation SystemKernelDebuggerInformation(0x23) 个人测试仅WIN 7有效NtQueryObject ObjectAllInformation(0x3) 这个较复杂，没测试，可参考http://www.voidcn.com/article/p-dhzpxayz-bbn.html 123456789101112131415161718192021222324252627typedef NTSTATUS(*NtQuerySytemInformationPtr)( _In_ int SystemInformationClass, _Inout_ PVOID SystemInformation, _In_ ULONG SystemInformationLength, _Out_opt_ PULONG ReturnLength );typedef struct _SYSTEM_KERNEL_DEBUGGER_INFORMATION&#123; BOOLEAN DebuggerEnabled; BOOLEAN DebuggerNotPresent;&#125; SYSTEM_KERNEL_DEBUGGER_INFORMATION, *PSYSTEM_KERNEL_DEBUGGER_INFORMATION;BOOL CheckDebug10()&#123; BOOL bdebugFlag = TRUE; HMODULE hModule = LoadLibrary(&quot;Ntdll.dll&quot;); NtQuerySytemInformationPtr NtQuerySystemInformation = (NtQuerySytemInformationPtr)GetProcAddress(hModule,&quot;NtQuerySystemInformation&quot;); ULONG SystemKernelDebuggerInformation = 0x23; ULONG ulReturnedLength = 0; SYSTEM_KERNEL_DEBUGGER_INFORMATION DebuggerInfo = &#123; 0, &#125;; NtQuerySystemInformation(SystemKernelDebuggerInformation,(PVOID)&amp;DebuggerInfo,sizeof(DebuggerInfo),&amp;ulReturnedLength); printf(&quot;NtQuerySystemInformation(SystemKernelDebuggerInformation) = 0x%X 0x%X\n&quot;,DebuggerInfo.DebuggerEnabled, DebuggerInfo.DebuggerNotPresent); return DebuggerInfo.DebuggerEnabled == TRUE;&#125; 1.4 GetLastError编写应用程序时，经常需要涉及到错误处理问题。许多函数调用只用TRUE和FALSE来表明函数的运行结果。一旦出现错误，MSDN中往往会指出请用GetLastError()函数来获得错误原因。恶意代码可以使用异常来破坏或者探测调试器。调试器捕获异常后，并不会立即将处理权返回被调试进程处理，大多数利用异常的反调试技术往往据此来检测调试器。多数调试器默认的设置是捕获异常后不将异常传递给应用程序。如果调试器不能将异常结果正确返回到被调试进程，那么这种异常失效可以被进程内部的异常处理机制探测。 该方法失效BOOL CheckDebug(){~ DWORD errorValue = 12345; ~~ SetLastError(errorValue);~ OutputDebugString(“Test for debugger!”); ~~ if (GetLastError() == errorValue) ~~ { ~~ return TRUE; ~~ } ~~ else ~~ { ~~ return FALSE; ~~ } ~} ~ DeleteFiber方法失效char fib[1024] = { 0 };DeleteFiber(fib);return (GetLastError() != 0x57); 不过这里存在方法还可以使用使用CloseHandle、ntclose、CloseWindow产生异常，使得错误码改变。 123456789101112BOOL CheckDebug() &#123; DWORD ret = CloseHandle((HANDLE)0x1234); if (ret != 0 || GetLastError() != ERROR_INVALID_HANDLE) &#123; return TRUE; &#125; else &#123; return FALSE; &#125; &#125; 1.5 ZwSetInformationThread 、NtCreateThreadEx注意，在strong OD中，似乎插件存在冲突，所以，在过这个的时候建议call xxx nop 掉，注意是nop call这条语句，注意堆栈平衡ZwSetInformationThread拥有两个参数，第一个参数用来接收当前线程的句柄，第二个参数表示线程信息类型，若其值设置为ThreadHideFromDebugger(0x11)，使用语句ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, NULL, 0);调用该函数后，调试进程就会被分离出来。该函数不会对正常运行的程序产生任何影响，但若运行的是调试器程序，因为该函数隐藏了当前线程，调试器无法再收到该线程的调试事件，最终停止调试。还有一个函数DebugActiveProcessStop用来分离调试器和被调试进程，从而停止调试。两个API容易混淆，需要牢记它们的区别接下来是一个ZwSetInformationThread的例子 123456789101112131415161718192021222324252627282930313233343536373839404142DWORD WINAPI MyThread()&#123; printf(&quot;thread\r\n&quot;); return 0;&#125;DWORD WINAPI MyThread2()&#123; printf(&quot;threa2\r\n&quot;); return 0;&#125;typedef NTSTATUS(*NtSetInformationThreadPtr)(HANDLE threadHandle, THREAD_INFORMATION_CLASS threadInformationClass, PVOID threadInformation, ULONG threadInformationLength);void MyNtSetInformationThreadApproach(HANDLE hThread)&#123; HMODULE hModule = LoadLibrary(TEXT(&quot;ntdll.dll&quot;)); NtSetInformationThreadPtr NtSetInformationThread = (NtSetInformationThreadPtr)GetProcAddress(hModule, &quot;NtSetInformationThread&quot;); NtSetInformationThread(hThread, (THREAD_INFORMATION_CLASS)0x11, 0, 0);&#125;int main()&#123; HANDLE hThread[2]; DWORD ThreadID; hThread[0] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)MyThread, NULL, 0, &amp;ThreadID); hThread[1] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)MyThread2, NULL, 0, &amp;ThreadID); MyNtSetInformationThreadApproach(hThread[0]); Sleep(10000); return 0;&#125; 测试过程，发现，只要在hThread[0]的回调下断点，就会崩溃，因为调试器下断CC，因为不能接受其断点，导致异常，故可以反调试，如果该API作用于主线程，则不能下断点，否则会崩溃。同理Windows Vista引入了NtCreateThreadEx函数，其签名如下： 12345678910111213NTSTATUS NTAPI NtCreateThreadEx ( _Out_ PHANDLE ThreadHandle, _In_ ACCESS_MASK DesiredAccess, _In_opt_ POBJECT_ATTRIBUTES ObjectAttributes, _In_ HANDLE ProcessHandle, _In_ PVOID StartRoutine, _In_opt_ PVOID Argument, _In_ ULONG CreateFlags, _In_opt_ ULONG_PTR ZeroBits, _In_opt_ SIZE_T StackSize, _In_opt_ SIZE_T MaximumStackSize, _In_opt_ PVOID AttributeList); 有趣的参数是CreateFlgs。此参数获取如下标志： 123456#define THREAD_CREATE_FLAGS_CREATE_SUSPENDED 0x00000001#define THREAD_CREATE_FLAGS_SKIP_THREAD_ATTACH 0x00000002#define THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER 0x00000004#define THREAD_CREATE_FLAGS_HAS_SECURITY_DESCRIPTOR 0x00000010#define THREAD_CREATE_FLAGS_ACCESS_CHECK_IN_TARGET 0x00000020#define THREAD_CREATE_FLAGS_INITIAL_THREAD 0x00000080 如果新线程获得THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER标志，则在创建时将对调试器隐藏该线程。这与NtSetInformationThread函数设置的ThreadHideFromDebugger相同。负责安全任务的代码可以在设置了THREAD_CREATE_FLAGS_HIDE_FROM_DEBUGGER标志的线程中执行。 DebugActiveProcessStop API，结合调试器，可以做出一个比较有趣的反调试或者反附加的方法。 2.手动检测数据结构虽然使用Windows API是探测调试器存在的最简单办法，但手动检查数据结构是恶意代码编写者最常使用的办法。这是因为很多时候通过Windows API实现的反调试技术无效，例如这些API函数被rootkit挂钩，并返回错误信息。因此，恶意代码编写者经常手动执行与这些API功能相同的操作。在手动检测中，PEB结构中的一些标志暴露了调试器存在的信息。这里，我们关注检测调试器存在常用的一些标志。 2.1 检测BeingDebugged属性Windows操作系统维护着每个正在运行的进程的PEB结构，它包含与这个进程相关的所有用户态参数。这些参数包括进程环境数据，环境数据包括环境变量、加载的模块列表、内存地址，以及调试器状态。就像我们之前说的PEB结构在32位和64位有些差别因为x64 VS不许内联汇编，所以这里就不举例子了关于x64的PEB结构可以参考https://www.jianshu.com/p/759082d40471 12345678910111213//x86BOOL CheckDebug6()&#123; int result = 0; __asm &#123; mov eax, fs:[30h] mov al, BYTE PTR[eax + 2] and eax,0x1 mov result, eax &#125; return result != 0;&#125; 2.2检测ProcessHeap属性Reserved数组中一个未公开的位置叫作ProcessHeap，它被设置为加载器为进程分配的第一个堆的位置。ProcessHeap位于PEB结构的0x18处。第一个堆头部有一个属性字段，它告诉内核这个堆是否在调试器中创建。这些属性叫作ForceFlags和Flags。在Windows XP系统中，ForceFlags属性位于堆头部偏移量0x10处；在Windows 7系统中，对于32位的应用程序来说ForceFlags属性位于堆头部偏移量0x44处。同样，恶意代码也可以检查Windows XP系统中偏移量0x0C处，或者Windows 7系统中偏移量0x40处的Flags属性。这个属性总与ForceFlags属性大致相同，但通常情况下Flags与值2进行比较。其中注意在VS中调试会出现问题，利用原版的OD查看是可以实现反调试的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859//ForceFlagsBOOL CheckDebug() &#123; int result = 0; DWORD dwVersion = GetVersion(); DWORD dwWindowsMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion))); //for xp if (dwWindowsMajorVersion == 5) &#123; __asm &#123; mov eax, fs:[30h] mov eax, [eax + 18h] mov eax, [eax + 10h] mov result, eax &#125; &#125; else &#123; __asm &#123; mov eax, fs:[30h] mov eax, [eax + 18h] mov eax, [eax + 44h] mov result, eax &#125; &#125; return result != 0; &#125; //FlagsBOOL CheckDebug() &#123; int result = 0; DWORD dwVersion = GetVersion(); DWORD dwWindowsMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion))); //for xp if (dwWindowsMajorVersion == 5) &#123; __asm &#123; mov eax, fs:[30h] mov eax, [eax + 18h] mov eax, [eax + 0ch] mov result, eax &#125; &#125; else &#123; __asm &#123; mov eax, fs:[30h] mov eax, [eax + 18h] mov eax, [eax + 40h] mov result, eax &#125; &#125; return result != 2; &#125; 2.3检测NTGlobalFlag由于调试器中启动进程与正常模式下启动进程有些不同，所以它们创建内存堆的方式也不同。系统使用PEB结构偏移量0x68处的一个未公开位置，来决定如何创建堆结构。如果这个位置的值为0x70，我们就知道进程正运行在调试器中。 123456789101112BOOL CheckDebug() &#123; int result = 0; __asm &#123; mov eax, fs:[30h] mov eax, [eax + 68h] and eax, 0x70 mov result, eax &#125; return result != 0; &#125; 操作系统创建堆时，值0x70是下列标志的一个组合。如果进程从调试器启动，那么进程的这些标志将被设置。(FLG_HEAP_ENABLE_TAIL_CHECK|FLG_HEAP_ENABLE_FREE_CHECK|FLG_HEAP_VALIDATE_PARAMETERS)避免这种问题方法和前面的差不多。如果用OllyDbg的命令行插件修改，输入的命令为dump fs:[30]+0x68。如果用PhantOm插件，它会逃避使用NTGlobalFlag的反调试技术而不需要手动设置。 2.4 扫描堆特征(只适用于XP)调试进程时，其堆内存就会出现一些特殊的标识，表示它正处于被调试状态。这些标识中最醒目的是在未使用的堆内存区域中填充着OxFEEEFEEE。我们利用这一特征即可判断进程是否处于被调试状态。PEB.Ldr成员指向一个_PEB_LDR_DATA结构体，而这个结构体就是在堆内存区域中创建的，所以我们可以扫描该区域来判断进程是否处于调试状态下。测试代码如下该代码并不适用WIN 7 WIN10 ，只适用于XP 1234567891011121314151617181920212223242526272829303132BOOL CheckDebug9()&#123; LPBYTE pLdr; DWORD pLdrSig[4] = &#123; 0xEEFEEEFE,0xEEFEEEFE,0xEEFEEEFE,0xEEFEEEFE &#125;; __asm &#123; mov eax, fs:[0x30]; //PEB地址 mov eax, [eax + 0xC];//Ldr mov pLdr, eax; &#125; __try &#123; while (1) &#123; if (!memcmp(pLdr, pLdrSig, sizeof(pLdrSig))) &#123; return true; &#125; else &#123; pLdr++; &#125; &#125; &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; return false; &#125;&#125; 3.系统痕迹检测通常，我们使用调试工具来分析恶意代码，但这些工具会在系统中驻留一些痕迹。恶意代码通过搜索这种系统痕迹，来确定你是否试图分析它。 3.1查找调试器引用的注册表项下面是调试器在注册表中的一个常用位置。SOFTWARE\Microsoft\Windows NT\CurrentVersion\AeDebug(32位系统)SOFTWARE\Wow6432Node\Microsoft\WindowsNT\CurrentVersion\AeDebug(64位系统)该注册表项指定当应用程序发生错误时，触发哪一个调试器。默认情况下，它被设置为Dr.Watson。如果该这册表的键值被修改为OllyDbg，则恶意代码就可能确定它正在被调试。 当然，现在很多调试器已经不会再这个位置，但是我们可以根据情况，打开regedit,存在调试器类的字符串就退出并删除程序，防止落入逆向人员的手中也是一种办法。 12345678910111213141516171819202122232425262728293031323334BOOL CheckDebug13()&#123; BOOL is_64; IsWow64Process(GetCurrentProcess(), &amp;is_64); HKEY hkey = NULL; char key[] = &quot;Debugger&quot;; char reg_dir_32bit[] = &quot;SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug&quot;; char reg_dir_64bit[] = &quot;SOFTWARE\\Wow6432Node\\Microsoft\\WindowsNT\\CurrentVersion\\AeDebug&quot;; DWORD ret = 0; if (is_64) &#123; ret = RegCreateKeyA(HKEY_LOCAL_MACHINE, reg_dir_64bit, &amp;hkey); &#125; else &#123; ret = RegCreateKeyA(HKEY_LOCAL_MACHINE, reg_dir_32bit, &amp;hkey); &#125; if (ret != ERROR_SUCCESS) &#123; return FALSE; &#125; char tmp[256]; DWORD len = 256; DWORD type; ret = RegQueryValueExA(hkey, key, NULL, &amp;type, (LPBYTE)tmp, &amp;len); if (strstr(tmp, &quot;OllyIce&quot;) != NULL || strstr(tmp, &quot;OllyDBG&quot;) != NULL || strstr(tmp, &quot;WinDbg&quot;) != NULL || strstr(tmp, &quot;x64dbg&quot;) != NULL || strstr(tmp, &quot;Immunity&quot;) != NULL) &#123; return TRUE; &#125; else &#123; return FALSE; &#125;&#125; 3.2查找窗体信息FindWindow函数检索处理顶级窗口的类名和窗口名称匹配指定的字符串。 1234567891011BOOL CheckDebug() &#123; if (FindWindowA(&quot;OLLYDBG&quot;, NULL)!=NULL || FindWindowA(&quot;WinDbgFrameClass&quot;, NULL)!=NULL || FindWindowA(&quot;QWidget&quot;, NULL)!=NULL) &#123; return TRUE; &#125; else &#123; return FALSE; &#125; &#125; EnumWindows函数枚举所有屏幕上的顶层窗口，并将窗口句柄传送给应用程序定义的回调函数。 12345678910111213141516BOOL CALLBACK EnumWndProc(HWND hwnd, LPARAM lParam) &#123; char cur_window[1024]; GetWindowTextA(hwnd, cur_window, 1023); if (strstr(cur_window, &quot;WinDbg&quot;)!=NULL || strstr(cur_window, &quot;x64_dbg&quot;)!=NULL || strstr(cur_window, &quot;OllyICE&quot;)!=NULL || strstr(cur_window, &quot;OllyDBG&quot;)!=NULL || strstr(cur_window, &quot;Immunity&quot;)!=NULL) &#123; *((BOOL*)lParam) = TRUE; &#125; return TRUE; &#125; BOOL CheckDebug() &#123; BOOL ret = FALSE; EnumWindows(EnumWndProc, (LPARAM)&amp;ret); return ret; &#125; GetForegroundWindow获取一个前台窗口的句柄。 12345678910111213BOOL CheckDebug() &#123; char fore_window[1024]; GetWindowTextA(GetForegroundWindow(), fore_window, 1023); if (strstr(fore_window, &quot;WinDbg&quot;)!=NULL || strstr(fore_window, &quot;x64_dbg&quot;)!=NULL || strstr(fore_window, &quot;OllyICE&quot;)!=NULL || strstr(fore_window, &quot;OllyDBG&quot;)!=NULL || strstr(fore_window, &quot;Immunity&quot;)!=NULL) &#123; return TRUE; &#125; else &#123; return FALSE; &#125; &#125; 3.3查找进程信息1234567891011121314151617181920212223BOOL CheckDebug() &#123; DWORD ID; DWORD ret = 0; PROCESSENTRY32 pe32; pe32.dwSize = sizeof(pe32); HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if(hProcessSnap == INVALID_HANDLE_VALUE) &#123; return FALSE; &#125; BOOL bMore = Process32First(hProcessSnap, &amp;pe32); while(bMore) &#123; if (stricmp(pe32.szExeFile, &quot;OllyDBG.EXE&quot;)==0 || stricmp(pe32.szExeFile, &quot;OllyICE.exe&quot;)==0 || stricmp(pe32.szExeFile, &quot;x64_dbg.exe&quot;)==0 || stricmp(pe32.szExeFile, &quot;windbg.exe&quot;)==0 || stricmp(pe32.szExeFile, &quot;ImmunityDebugger.exe&quot;)==0) &#123; return TRUE; &#125; bMore = Process32Next(hProcessSnap, &amp;pe32); &#125; CloseHandle(hProcessSnap); return FALSE; &#125; 二、识别调试器行为在逆向工程中，为了帮助恶意代码分析人员进行分析，可以使用调试器设置一个断点，或是单步执行一个进程。然而，在调试器中执行这些操作时，它们会修改进程中的代码。因此，恶意代码常使用几种反调试技术探测软件/硬件断点、完整性校验、时钟检测等几种类型的调试器行为。直接运行恶意代码与在调试器中运行恶意代码也会在一些细节上不同，如父进程信息、STARTUPINFO信息、SeDebugPrivilege权限等。 1.软件断点检查调试器设置断点的基本机制是用软件中断指令INT 3临时替换运行程序中的一条指令，然后当程序运行到这条指令时，调用调试异常处理例程。INT 3指令的机器码是0xCC，因此无论何时，使用调试器设置一个断点，它都会插入一个0xCC来修改代码。恶意代码常用的一种反调试技术是在它的代码中查找机器码0xCC，来扫描调试器对它代码的INT 3修改。repne scasb指令用于在一段数据缓冲区中搜索一个字节。EDI需指向缓冲区地址，AL则包含要找的字节，ECX设为缓冲区的长度。当ECX=0或找到该字节时，比较停止。底下这个例子并不是很准却的检查，以为很可能原始软件存在CC的编码，导致误报，对于这个问题，可以先扫描，保存其断点，然后，第二次再次扫描，与之对比，进行检查。代码如下，当然最好开线程跑，演示可以边调试边跑，随便打个断点，测试，然后自己加工一下代码就可以了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869BOOL CheckDebug14()&#123; int CCAry[100] = &#123; 0 &#125;; int addr = 0; PIMAGE_DOS_HEADER pDosHeader; PIMAGE_NT_HEADERS32 pNtHeaders; PIMAGE_SECTION_HEADER pSectionHeader; DWORD dwBaseImage = (DWORD)GetModuleHandle(NULL); pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage; pNtHeaders = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew); pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders + sizeof(pNtHeaders-&gt;Signature) + sizeof(IMAGE_FILE_HEADER) + (WORD)pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader); DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage; DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData; BOOL Found = FALSE; //原始代码中的CC __asm &#123; cld lea ebx, CCAry mov edx, 0 mov edi, dwAddr mov ecx, dwCodeSize mov al, 0CBH xor al,7 MYLOOP: and ecx,ecx jz OVER repne scasb mov [ebx],edi add ebx,4 jmp MYLOOP mov addr, edi OVER : &#125; //for (size_t i = 0; i &lt; 100; i++) //&#123; // printf(&quot;%08x &quot;, CCAry[i]); //&#125; //检测CC while (!Found) &#123; Sleep(1000); __asm &#123; cld mov ecx, dwCodeSize mov edi, dwAddr MYLOOP2: mov al, 0CCH and ecx,ecx jz NOTFOUND repne scasb push ecx push edi mov eax, edi lea edi, CCAry mov ecx,100 repne scasd pop edi pop ecx jz MYLOOP2 mov Found, 1 NOTFOUND: &#125; &#125; return Found;&#125; 2.硬件断点检查在OllyDbg的寄存器窗口按下右键，点击View debug registers可以看到DR0、DR1、DR2、DR3、DR6和DR7这几个寄存器。DR0、Dr1、Dr2、Dr3用于设置硬件断点，由于只有4个硬件断点寄存器，所以同时最多只能设置4个硬件断点。DR4、DR5由系统保留。 DR6、DR7用于记录Dr0-Dr3中断点的相关属性。如果没有硬件断点，那么DR0、DR1、DR2、DR3这4个寄存器的值都为0。 123456789101112BOOL CheckDebug() &#123; CONTEXT context; HANDLE hThread = GetCurrentThread(); context.ContextFlags = CONTEXT_DEBUG_REGISTERS; GetThreadContext(hThread, &amp;context); if (context.Dr0 != 0 || context.Dr1 != 0 || context.Dr2 != 0 || context.Dr3!=0) &#123; return TRUE; &#125; return FALSE; &#125; 3.执行代码校验和检查恶意代码可以计算代码段的校验并实现与扫描中断相同的目的。与扫描0xCC不同，这种检查仅执行恶意代码中机器码CRC或者MD5校验和检查。一般操作首先读取文件代码段或者之前的一个内存校验值，计算一个原始校验值，然后读取映射后的代码，计算校验值，然后二者对比 123456789101112131415161718192021222324252627282930313233343536//获取内存PIMAGE_DOS_HEADER pDosHeader;PIMAGE_NT_HEADERS32 pNtHeaders;PIMAGE_SECTION_HEADER pSectionHeader;DWORD dwBaseImage = (DWORD)GetModuleHandle(NULL);pDosHeader = (PIMAGE_DOS_HEADER)dwBaseImage;pNtHeaders = (PIMAGE_NT_HEADERS32)((DWORD)pDosHeader + pDosHeader-&gt;e_lfanew);pSectionHeader = (PIMAGE_SECTION_HEADER)((DWORD)pNtHeaders + sizeof(pNtHeaders-&gt;Signature) + sizeof(IMAGE_FILE_HEADER) + (WORD)pNtHeaders-&gt;FileHeader.SizeOfOptionalHeader);DWORD dwAddr = pSectionHeader-&gt;VirtualAddress + dwBaseImage;DWORD dwCodeSize = pSectionHeader-&gt;SizeOfRawData;DWORD checksum = 0;__asm&#123; cld mov esi, dwAddr mov ecx, dwCodeSize xor eax, eax checksum_loop : movzx ebx, byte ptr[esi] add eax, ebx rol eax, 1 inc esi loop checksum_loop mov checksum, eax&#125;//文件计算出来的原始的值,或者之前的内存值if (checksum != 12345)&#123; return FALSE;&#125;else&#123; return TRUE;&#125; 4.时钟检测被调试时，进程的运行速度大大降低，例如，单步调试大幅降低恶意代码的运行速度，所以时钟检测是恶意代码探测调试器存在的最常用方式之一。有如下两种用时钟检测来探测调试器存在的方法。记录一段操作前后的时间戳，然后比较这两个时间戳，如果存在滞后，则可以认为存在调试器。记录触发一个异常前后的时间戳。如果不调试进程，可以很快处理完异常，因为调试器处理异常的速度非常慢。默认情况下，调试器处理异常时需要人为干预，这导致大量延迟。虽然很多调试器允许我们忽略异常，将异常直接返回程序，但这样操作仍然存在不小的延迟。 4.1使用rdtsc指令较常用的时钟检测方法是利用rdtsc指令(操作码0x0F31)，它返回至系统重新启动以来的时钟数，并且将其作为一个64位的值存入EDX:EAX中。恶意代码运行两次rdtsc指令，然后比较两次读取之间的差值。 12345678910111213141516171819BOOL CheckDebug() &#123; DWORD time1, time2; __asm &#123; rdtsc mov time1, eax rdtsc mov time2, eax &#125; if (time2 - time1 &lt; 0xff) &#123; return FALSE; &#125; else &#123; return TRUE; &#125; &#125; 4.2使用QueryPerformanceCounter和GetTickCount同rdtsc指令一样，这两个Windows API函数也被用来执行一个反调试的时钟检测。使用这种方法的前提是处理器有高分辨率能力的计数器-寄存器，它能存储处理器活跃的时钟数。为了获取比较的时间差，调用两次QueryPerformanceCounter函数查询这个计数器。若两次调用之间花费的时间过于长，则可以认为正在使用调试器。GetTickCount函数返回最近系统重启时间与当前时间的相差毫秒数(由于时钟计数器的大小原因，计数器每49.7天就被重置一次)。 12345678910111213141516171819BOOL CheckDebug() &#123; DWORD time1 = GetTickCount(); __asm &#123; mov ecx,10 mov edx,6 mov ecx,10 &#125; DWORD time2 = GetTickCount(); if (time2-time1 &gt; 0x1A) &#123; return TRUE; &#125; else &#123; return FALSE; &#125; &#125; 5.判断父进程是否是explorer.exe一般双击运行的进程的父进程都是explorer.exe，但是如果进程被调试父进程则是调试器进程。也就是说如果父进程不是explorer.exe则可以认为程序正在被调试后边说的NtQueryInformationProcess这个方法，在VS下Debug进行调试，是可以检测，且这个结构成立，但是在非调试状态，这个结构好像并不能检查 123456789typedef struct&#123; DWORD ExitStatus; // 接收进程终止状态 DWORD PebBaseAddress; // 接收进程环境块地址 DWORD AffinityMask; // 接收进程关联掩码 DWORD BasePriority; // 接收进程的优先级类 ULONG UniqueProcessId; // 接收进程ID ULONG InheritedFromUniqueProcessId; // 接收父进程ID&#125; PROCESS_BASIC_INFORMATION; 所以想了想，把代码贴上,有错误请指教 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051//个人测试，代码行不通typedef struct&#123; DWORD ExitStatus; // 接收进程终止状态 DWORD PebBaseAddress; // 接收进程环境块地址 DWORD AffinityMask; // 接收进程关联掩码 DWORD BasePriority; // 接收进程的优先级类 ULONG UniqueProcessId; // 接收进程ID ULONG InheritedFromUniqueProcessId; // 接收父进程ID&#125; PROCESS_BASIC_INFORMATION;BOOL CheckDebug17()&#123; LONG status; DWORD dwParentPID = 0; HANDLE hProcess; PROCESS_BASIC_INFORMATION pbi; int pid = GetCurrentProcessId(); hProcess = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid); if (!hProcess) return -1; NtQueryInformationProcessPtr NtQueryInformationProcess = (NtQueryInformationProcessPtr)GetProcAddress(GetModuleHandleA(&quot;ntdll&quot;), &quot;NtQueryInformationProcess&quot;); status = NtQueryInformationProcess(hProcess, 0, (PVOID)&amp;pbi, sizeof(PROCESS_BASIC_INFORMATION), NULL); PROCESSENTRY32 pe32; pe32.dwSize = sizeof(pe32); HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if (hProcessSnap == INVALID_HANDLE_VALUE) &#123; return FALSE; &#125; printf(&quot;%d %d\r\n&quot;, pid, pbi.InheritedFromUniqueProcessId); BOOL bMore = Process32First(hProcessSnap, &amp;pe32); while (bMore) &#123; if (pbi.InheritedFromUniqueProcessId == pe32.th32ProcessID) &#123; printf(&quot;%d %d %s\r\n&quot;, pbi.InheritedFromUniqueProcessId, pe32.th32ProcessID, pe32.szExeFile); if (stricmp(pe32.szExeFile, &quot;explorer.exe&quot;) == 0) &#123; CloseHandle(hProcessSnap); return FALSE; &#125; else &#123; CloseHandle(hProcessSnap); return TRUE; &#125; &#125; bMore = Process32Next(hProcessSnap, &amp;pe32); &#125; CloseHandle(hProcessSnap);&#125; 利用其他方法检查 123456789101112131415161718192021222324252627282930313233343536373839404142// Search each process in the snapshot for id. BOOL FindProcessID(HANDLE snap, DWORD id, LPPROCESSENTRY32 ppe)&#123; BOOL fOk; ppe-&gt;dwSize = sizeof(PROCESSENTRY32); for (fOk = Process32First(snap, ppe); fOk; fOk = Process32Next(snap, ppe)) if (ppe-&gt;th32ProcessID == id) break; return fOk;&#125;// Obtain the process and thread identifiers of the parent process. BOOL CheckDebug18()&#123; HANDLE hSnap; PROCESSENTRY32 pe; DWORD id = GetCurrentProcessId(); BOOL fOk; //获取系统所有进程和线程 hSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, id); if (hSnap == INVALID_HANDLE_VALUE) return FALSE; //获取父进程PID FindProcessID(hSnap, id, &amp;pe); //检查父进程是否存在 if (!FindProcessID(hSnap, pe.th32ParentProcessID, &amp;pe)) &#123; CloseHandle(hSnap); return FALSE; &#125; //printf(&quot;%s&quot;, pe.szExeFile); if (strcmp(pe.szExeFile,&quot;explorer.exe&quot;)) &#123; return TRUE; &#125; else &#123; return FALSE; &#125; return fOk;&#125; 6.判断STARTUPINFO信息explorer.exe创建进程的时候会把STARTUPINFO结构中的值设为0，而非explorer.exe创建进程的时候会忽略这个结构中的值，也就是结构中的值不为0。所以可以利用STARTUPINFO来判断程序是否在被调试。 12345678910111213BOOL CheckDebug() &#123; STARTUPINFO si; GetStartupInfo(&amp;si); if (si.dwX!=0 || si.dwY!=0 || si.dwFillAttribute!=0 || si.dwXSize!=0 || si.dwYSize!=0 || si.dwXCountChars!=0 || si.dwYCountChars!=0) &#123; return TRUE; &#125; else &#123; return FALSE; &#125; &#125; 7.判断是否具有SeDebugPrivilege权限默认情况下进程是没有SeDebugPrivilege权限的，但是当进程通过调试器启动时，由于调试器本身启动了SeDebugPrivilege权限，当调试进程被加载时SeDebugPrivilege也就被继承了。所以我们可以检测进程的SeDebugPrivilege权限来间接判断是否存在调试器，而对SeDebugPrivilege权限的判断可以用能否打开csrss.exe进程来判断。（WIN7 有效，似乎WIN 10不能随便打开CSRSS了，可以挑一个其他的。） 12345678910111213141516171819202122232425262728293031BOOL CheckDebug() &#123; DWORD ID; DWORD ret = 0; PROCESSENTRY32 pe32; pe32.dwSize = sizeof(pe32); HANDLE hProcessSnap = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); if(hProcessSnap == INVALID_HANDLE_VALUE) &#123; return FALSE; &#125; BOOL bMore = Process32First(hProcessSnap, &amp;pe32); while(bMore) &#123; if (strcmp(pe32.szExeFile, &quot;csrss.exe&quot;)==0) &#123; ID = pe32.th32ProcessID; break; &#125; bMore = Process32Next(hProcessSnap, &amp;pe32); &#125; CloseHandle(hProcessSnap); if (OpenProcess(PROCESS_QUERY_INFORMATION, NULL, ID) != NULL) &#123; return TRUE; &#125; else &#123; return FALSE; &#125; &#125; 三、干扰调试器的功能恶意代码可以用一些技术来干扰调试器的正常运行。例如线程本地存储(TLS)回调、插入中断、异常等。这些技术当且仅当程序处于调试器控制之下时才试图扰乱程序的运行。 1.使用TLS回调Thread Local Storage(TLS)，即线程本地存储，是Windows为解决一个进程中多个线程同时访问全局变量而提供的机制。TLS可以简单地由操作系统代为完成整个互斥过程，也可以由用户自己编写控制信号量的函数。当进程中的线程访问预先制定的内存空间时，操作系统会调用系统默认的或用户自定义的信号量函数，保证数据的完整性与正确性。下面是一个简单的TLS回调的例子，TLS_CALLBACK1函数在main函数执行前调用IsDebuggerPresent函数检查它是否正在被调试。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt; #include &lt;windows.h&gt; void NTAPI __stdcall TLS_CALLBACK1(PVOID DllHandle, DWORD dwReason, PVOID Reserved);#ifdef _M_IX86 #pragma comment (linker, &quot;/INCLUDE:__tls_used&quot;) #pragma comment (linker, &quot;/INCLUDE:__tls_callback&quot;) #else #pragma comment (linker, &quot;/INCLUDE:_tls_used&quot;) #pragma comment (linker, &quot;/INCLUDE:_tls_callback&quot;) #endif EXTERN_C#ifdef _M_X64 #pragma const_seg (&quot;.CRT$XLB&quot;) const#else #pragma data_seg (&quot;.CRT$XLB&quot;) #endif PIMAGE_TLS_CALLBACK _tls_callback[] = &#123; TLS_CALLBACK1,0 &#125;;#pragma data_seg () #pragma const_seg () #include &lt;iostream&gt; void NTAPI __stdcall TLS_CALLBACK1(PVOID DllHandle, DWORD Reason, PVOID Reserved)&#123; if (IsDebuggerPresent()) &#123; printf(&quot;TLS_CALLBACK: Debugger Detected!\n&quot;); &#125; else &#123; printf(&quot;TLS_CALLBACK: No Debugger Present!\n&quot;); &#125;&#125;int main(int argc, char* argv[])&#123; printf(&quot;233\n&quot;); system(&quot;pause&quot;); return 0;&#125; 要在程序中使用TLS，必须为TLS数据单独建一个数据段，用相关数据填充此段，并通知链接器为TLS数据在PE文件头中添加数据。_tls_callback[]数组中保存了所有的TLS回调函数指针。数组必须以NULL指针结束，且数组中的每一个回调函数在程序初始化时都会被调用，程序员可按需要添加。但程序员不应当假设操作系统已何种顺序调用回调函数。如此则要求在TLS回调函数中进行反调试操作需要一定的独立性。正常运行这个程序会打印下面的内容。 1234TLS_CALLBACK: No Debugger Present!233//如果把在OllyDbg中运行，在OllyDbg暂停之前会打印下面的内容。TLS_CALLBACK: Debugger Detected! 使用PEview查看.tls段，可以发现TLS回调函数。通常情况下，正常程序不使用.tls段，如果在可执行程序中看到.tls段，应该立即怀疑它使用了反调试技术。了解原理在OllyDbg中选择Options-&gt;Debugging Options-&gt;Events，然后设置System break-point作为第一个暂停的位置，这样就可以让OllyDbg在TLS回调执行前暂停。IDA查看按Ctrl+E快捷键看到二进制的入口点，该组合键的作用是显示应用程序所有的入口点，其中包括TLS回调。双击函数名可以浏览回调函数由于TLS回调已广为人知，因此同过去相比，恶意代码使用它的次数已经明显减少。为数不多的合法程序使用TLS回调，所以可执行程序中的.tls段特别突出。 2.利用中断int 3因为调试器使用INT 3来设置软件断点，所以一种反调试技术就是在合法代码段中插入0xCC(INT 3)欺骗调试器，使其认为这些0xCC机器码是自己设置的断点。 123456789101112BOOL CheckDebug() &#123; __try &#123; __asm int 3 &#125; __except(1) &#123; return FALSE; &#125; return TRUE; &#125; SEH（INT 3，这里简单说，后边涉及VEH，在拿出来单独看一下）除了使用_try和_except以外还可以直接使用汇编代码安装SEH。在下面的代码中如果进程没有处于调试中，则正常终止；如果进程处于调试中，则跳转到非法地址0xFFFFFFFF处，无法继续调试。自己安装的一场大部分调试器会崩溃，包括吾爱的调试器 1234567891011121314151617181920212223242526272829303132333435void CheckDebug() &#123; printf(&quot;SEH : BreakPoint\n&quot;); __asm &#123; // install SEH push handler push DWORD ptr fs:[0] mov DWORD ptr fs:[0], esp // generating exception int 3 // 1) debugging // go to terminating code mov eax, 0xFFFFFFFF jmp eax // process terminating!!! // 2) not debugging // go to normal code handler: mov eax, dword ptr ss:[esp+0xc] mov ebx, normal_code mov dword ptr ds:[eax+0xb8], ebx xor eax, eax retn normal_code: // remove SEH pop dword ptr fs:[0] add esp, 4 &#125; printf(&quot; =&gt; Not debugging...\n\n&quot;); &#125; 0xCD03双字节操作码0xCD03也可以产生INT 3中断，这是恶意代码干扰WinDbg调试器的有效方法。在调试器外，0xCD03指令产生一个STATUS_BREAKPOINT异常。然而在WinDbg调试器内，由于断点通常是单字节机器码0xCC，因此WinDbg会捕获这个断点然后将EIP加1字节。这可能导致程序在被正常运行的WinDbg调试时，执行不同的指令集(OllyDbg可以避免双字节INT 3的攻击)。 12345678910111213141516BOOL CheckDebug() &#123; __try &#123; __asm &#123; __emit 0xCD __emit 0x03 &#125; &#125; __except(1) &#123; return FALSE; &#125; return TRUE; &#125; int 2DINT 2D原为内核模式中用来触发断点异常的指令，也可以在用户模式下触发异常。但程序调试运行时不会触发异常，只是忽略。INT 2D指令在ollydbg中有两个有趣的特性。在调试模式中执行INT 2D指令，下一条指令的第一个字节将被忽略。使用StepInto(F7)或者StepOver(F8)命令跟踪INT 2D指令，程序不会停在下一条指令开始的地方，而是一直运行，就像RUN(F9)一样。在下面的代码中，程序调试运行时，执行INT 2D之后不会运行SEH，而是跳过NOP，把bDebugging标志设置为1，跳转到normal_code；程序正常运行时，执行INT 2D之后触发SEH，在异常处理器中设置EIP并把bDebugging标志设置为0。 123456789101112131415161718192021222324252627282930313233BOOL CheckDebug24()&#123; BOOL bDebugging = FALSE; __asm &#123; // install SEH push handler push DWORD ptr fs : [0] mov DWORD ptr fs : [0], esp int 0x2d nop mov bDebugging, 1 jmp normal_code handler : mov eax, dword ptr ss : [esp + 0xc] mov dword ptr ds : [eax + 0xb8], offset normal_code mov bDebugging, 0 xor eax, eax retn normal_code : // remove SEH pop dword ptr fs : [0] add esp, 0xC &#125; printf(&quot;Trap Flag (INT 2D)\n&quot;); if (bDebugging) return 1; else return 0;&#125; 0xF1片内仿真器(ICE)断点指令ICEBP(操作码0xF1)是Intel未公开的指令之一。由于使用ICE难以在任意位置设置断点，因此ICEBP指令被设计用来降低使用ICE设置断点的难度。运行ICEBP指令将会产生一个单步异常，如果通过单步调试跟踪程序，调试器会认为这是单步调试产生的异常，从而不执行先前设置的异常处理例程。利用这一点，恶意代码使用异常处理例程作为它的正常执行流程。为了防止这种反调试技术，执行ICEBP指令时不要使用单步。 123456789101112BOOL CheckDebug() &#123; __try &#123; __asm __emit 0xF1 &#125; __except(1) &#123; return FALSE; &#125; return TRUE; &#125; 堆栈段操作在操作ss堆栈段寄存器时，调试器跳过指令跟踪。在下一个示例中，调试器将立即移到 xor edx, edx 指令，同时执行上一个指令,没什么用，其实跳过的编码还是执行了，就是跳了一下。 1234567__asm&#123; push ss pop ss mov eax, 0xC000C1EE // This line will be traced over by debugger xor edx, edx // Debugger will step to this line&#125; 3.设置陷阱标志位（TF）EFLAGS寄存器的第八个比特位是陷阱标志位。如果设置了，就会产生一个单步异常。 123456789101112131415161718BOOL CheckDebug() &#123; __try &#123; __asm &#123; pushfd or word ptr[esp], 0x100 popfd nop &#125; &#125; __except(1) &#123; return FALSE; &#125; return TRUE; &#125; 使用异常4.1RaiseExceptionRaiseException函数产生的若干不同类型的异常可以被调试器捕获。 1234567891011121314151617BOOL TestExceptionCode(DWORD dwCode) &#123; __try &#123; RaiseException(dwCode, 0, 0, 0); &#125; __except(1) &#123; return FALSE; &#125; return TRUE; &#125; BOOL CheckDebug() &#123; return TestExceptionCode(DBG_RIPEXCEPTION); &#125; 4.2SetUnhandledExceptionFilter进程中发生异常时若SEH未处理或注册的SEH不存在，会调用UnhandledExceptionFilter，它会运行系统最后的异常处理器。UnhandledExceptionFilter内部调用了前面提到过的NtQueryInformationProcess以判断是否正在调试进程。若进程正常运行，则运行最后的异常处理器；若进程处于调试，则将异常派送给调试器。SetUnhandledExceptionFilter函数可以修改系统最后的异常处理器。下面的代码先触发异常，然后在新注册的最后的异常处理器内部判断进程正常运行还是调试运行。进程正常运行时pExcept-&gt;ContextRecord-&gt;Eip+=4;将发生异常的代码地址加4使得其能够继续运行；进程调试运行时产生无效的内存访问异常，从而无法继续调试。 12345678910111213141516171819202122232425262728LPVOID g_pOrgFilter = 0;LONG WINAPI ExceptionFilter(PEXCEPTION_POINTERS pExcept)&#123; SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)g_pOrgFilter); // 8900 MOV DWORD PTR DS:[EAX], EAX // FFE0 JMP EAX pExcept-&gt;ContextRecord-&gt;Eip += 4; return EXCEPTION_CONTINUE_EXECUTION;&#125;void AD_SetUnhandledExceptionFilter()&#123; printf(&quot;SEH : SetUnhandledExceptionFilter()\n&quot;); g_pOrgFilter = (LPVOID)SetUnhandledExceptionFilter( (LPTOP_LEVEL_EXCEPTION_FILTER)ExceptionFilter); __asm &#123; xor eax, eax; mov dword ptr[eax], eax jmp eax &#125; printf(&quot; =&gt; Not debugging...\n\n&quot;);&#125; 4.3 VEHVeh是在WindowsXP中引入的，是SEH的变体。Veh和SEH不是相互依赖的，他们两个是可以同时工作的。添加新的VEH处理程序时，SEH链不会受到影响，因为VEH处理程序列表存储在ntdll!LdrpVectorHandlerList未导出变量中。VEH和SEH机制非常相似，唯一的区别是公开的函数用于设置和删除VEH处理程序。添加和删除VEH处理程序以及VEH处理函数的原函数签名如下 123456789101112131415PVOID WINAPI AddVectoredExceptionHandler( ULONG FirstHandler, PVECTORED_EXCEPTION_HANDLER VectoredHandler);ULONG WINAPI RemoveVectoredExceptionHandler( PVOID Handler);LONG CALLBACK VectoredHandler( PEXCEPTION_POINTERS ExceptionInfo);The _EXCEPTION_POINTERS structure looks like this: typedef struct _EXCEPTION_POINTERS &#123; PEXCEPTION_RECORD ExceptionRecord; PCONTEXT ContextRecord;&#125; EXCEPTION_POINTERS, *PEXCEPTION_POINTERS; 在处理程序中接收控制权之后，系统收集当前进程上下文并通过ContextRecord参数传递。下面是使用向量异常处理的反调试保护代码示例： 123456789101112131415161718LONG CALLBACK ExceptionHandler(PEXCEPTION_POINTERS ExceptionInfo)&#123; PCONTEXT ctx = ExceptionInfo-&gt;ContextRecord; //检测硬件断点 if (ctx-&gt;Dr0 != 0 || ctx-&gt;Dr1 != 0 || ctx-&gt;Dr2 != 0 || ctx-&gt;Dr3 != 0) &#123; std::cout &lt;&lt; &quot;Stop debugging program!&quot; &lt;&lt; std::endl; exit(-1); &#125; //返回源程序 ctx-&gt;Eip += 2; return EXCEPTION_CONTINUE_EXECUTION;&#125;BOOL CheckDebug29()&#123; AddVectoredExceptionHandler(0, ExceptionHandler); __asm int 3h;&#125; 四、调试信息(本质还是异常)自Windows10以来，OutputDebugString函数的实现已更改为带有特定参数的简单RaiseException调用。因此，调试输出异常现在必须由调试器处理。有两种异常类型：DBG_PRINTEXCEPTION_C(0x40010006)和DBG_PRINTEXCEPTION_W(0x4001000A)，可用于检测调试器是否存在 1234567891011121314BOOL CheckDebug29()&#123; ULONG_PTR args[4] = &#123; 0 &#125;; CHAR * outputString = (CHAR *)&quot;Any text&quot;; args[0] = (ULONG_PTR)strlen(outputString) + 1; args[1] = (ULONG_PTR)outputString; __try &#123; RaiseException(DBG_PRINTEXCEPTION_WIDE_C, 0, 4, args); return TRUE;//printf(&quot;Debugger detected&quot;); &#125; __except (EXCEPTION_EXECUTE_HANDLER) &#123; return FALSE;//printf(&quot;Debugger NOT detected&quot;); 参考链接:反调试技术总结 静态反调试技术Windows 反调试参考翻译]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>AntiDebug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址和子网划分学习笔记之《子网划分详解》]]></title>
    <url>%2F2019%2F09%2F30%2FIP%E5%9C%B0%E5%9D%80%E5%92%8C%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E8%AF%A6%E8%A7%A3%E3%80%8B%2F</url>
    <content type="text"><![CDATA[知识结构:IP地址和子网划分学习笔记之《预备知识：进制计数》IP地址和子网划分学习笔记之《IP地址详解》IP地址和子网划分学习笔记之《子网掩码详解》IP地址和子网划分学习笔记之《子网划分详解》IP地址和子网划分学习笔记之《超网合并详解》 原文出处:https://blog.51cto.com/6930123/2113151 IP地址和子网划分学习笔记之《子网划分详解》一，子网划分概述1、为什么要划分子网？IPv4地址如果只使用有类（A、B、C类）来划分，会造成大量的浪费或者不够用，为了解决这个问题，可以在有类网络的基础上，通过对IP地址的主机号进行再划分，把一部分划入网络号，就能划分各种类型大小的网络了。 2、IPv4子网划分与聚合为了解决IPv4的不足，提高网络划分的灵活性，诞生了两种非常重要的技术，那就是VLSM（可变长子网掩码）和CIDR（无类别域间路由），把传统标准的IPv4有类网络演变成一个更为高效，更为实用的无类网络。关于VLSM和CIDR的介绍参考上篇子网掩码详解有讲述。 VLSM用于IPv4子网的划分，也就是把一个大的网络划分成多个小的子网；而CIDR则用于IPv4子网的聚合，当然主要是指路由方面的聚合，也就是路由汇总。通过CIDR可以把多个小的子网路由条目汇总成一个大网络的路由条目，以减少路由器中路由条目的数量，提高路由效率 二、子网划分方法我们所讲的子网划分其实就是基于VLSM可变长子网掩码的划分，子网划分又分为等长子网划分和变长子网划分。 1、VLSM子网划分的基本思想通过VLSM实现子网划分的基本思想很简单：就是借用现有网段的主机位的最左边某几位作为子网位，划分出多个子网。 ①、把原来有类网络IPv4地址中的“网络ID”部分向“主机ID”部分借位 ②、把一部分原来属于“主机ID”部分的位变成“网络ID”的一部分（通常称之为“子网ID”）。 ③、原来的“网络ID”+“子网ID”=新“网络ID”。“子网ID”的长度决定了可以划分子网的数量。 如下示例图： 2、全0子网与全1子网①、“全0子网”代表的是对应子网的“子网ID”部分各位都是0，是第一个子网。 ②、“全1子网”代表的是对应子网的“子网ID”部分各位都是1，是最后一个子网。 ③、按照RFC950参考规定，划分子网后，只有n-2个可用的子网（n表示总的子网数）。 ④、后来RFC1878参考规定，划分子网后，可以有n个可用的子网（n表示总的子网数）。 RFC950参考规定：第一个子网（也就是“全0子网”）和最后一个子网（也就是“全1子网”）不可用，为的就是避免全0子网的网络地址和全1子网的广播地址分别与没有划分子网前的网络地址和广播地址相冲突。 但是在后来RFC1878规定中，该项规定已被废止了，现在的设备基本上都普遍支持RFC1878。 三、等长子网和变长子网划分子网划分的任务包括： ①、确定子网掩码的长度。 ②、确定子网下的主机可用地址范围（第一个可用IP和最后一个可用IP）。 ③、确定网络地址（主机位全为0）和广播地址（主机位全为1），不能分配计算机主机用。 Ⅰ、等长子网划分等长子网划分就是将一个有类网络等分成多个网络，也就是等分成多个子网，所有子网的子网掩码都相同。 1、C类网络子网划分示例①、等分为两个子网将192.168.0.0 255.255.255.0这个网络等分成2个子网，并写出每个子网的地址信息？分析：该网络子网掩码为/24，要划分为2个子网，要借用主机位1位作为子网位。因为二进制数0和1按一位排列组合，只有这2种，分别为：0，1，如下图所示。0是A子网1是B子网借用主机1位，所以子网掩码+1位，由原来的255.255.255.0 （/24）变为255.255.255.128（/25） 结论：C类网络等分成2个子网，子网掩码往右移动1位，就能等分成2个子网，即2^1最终结果： A子网的网络地址：192.168.0.0/25，可用地址（192.168.0.1～192.168.0.126），广播地址：192.168.0.127。B子网的网络地址：192.168.0.128/25，可用地址（192.168.0.129～192.168.0.254），广播地址：192.168.0.255 ②、等分为四个子网同样将192.168.0.0 255.255.255.0 这个网络等分成4个子网分析：要想分成4个子网，需要将子网掩码往右移动两位这样第1位和第2位就变为网络位，就可以分成4个子网因为二进制数0和1按两位排列组合，只有这4种，分别为：00，01，10，11，如下图所示。 00是A子网01是B子网10是C子网11是D子网 借用主机2位，所以子网掩码+2位，由原来的255.255.255.0 （/24）变为255.255.255.192 （/26）结论：C类网络等分成4个子网，子网掩码往右移动2位，就能等分成4个子网，即2^2。最终结果：A子网的网络地址：192.168.0.0/26，可用地址（192.168.0.1～192.168.0.62），广播地址：192.168.0.63/26。B子网的网络地址：192.168.0.64/26，可用地址（192.168.65～192.168.0.126），广播地址：192.168.0.127。C子网的网络地址：192.168.0.128/26，可用地址（192.168.129～192.168.0.190），广播地址：192.168.0.191。D子网的网络地址：192.168.0.192/26，可用地址（192.168.193/26～192.168.0.254），广播地址：192.168.0.255。 ③、等分为八个子网把一个C类网络等分成8个子网，如下图所示，子网掩码需要往右移3位。这样才能划分出8个子网，主机位的第1位、第2位和第3位都变成网络位。结论：C类网络等分成8个子网，子网掩码往右移动3位，就能等分成8个子网，即2^3。 同理 B类子网划分2、B类网络子网划分示例将131.107.0.0/16等分成2个子网，写出各个子网的第一个和最后一个可用的IP地址？分析：要划分为2个子网，就要借用主机位1位作为子网位。0是A子网1是B子网借用主机1位，所以子网掩码+1位，由原来的255.255.0.0 （/16）变为255.255.128.0（/17）结论：B类网络等分成2个子网，子网掩码往右移动1位，就能等分成2个子网，即2^1。最终结果：A子网网络地址：131.107.0.0/17，可用地址（131.107.0.1 ~ 131.107.127.254）广播地址：131.107.127.255B子网网络地址：131.107.128.0/17可用地址（131.107.128.1 ~ 131.107.255.254）广播地址：131.107.255.255 3、A类网络子网划分示例将A类网络42.0.0.0/8等分成4个子网，写出各个子网的第一个和最后一个可用的IP地址？分析：要划分为4个子网，就要借用主机位2位作为子网位00是A子网01是B子网10是C子网11是D子网借用主机2位，所以子网掩码+2位，由原来的255.0.0.0 （/8）变为255.192.0.0（/10）结论：A类网络等分成4个子网，子网掩码往右移动2位，就能等分成4个子网，即2^2。最终结果：A子网的网络地址：40.0.0.0/10，可用地址（40.0.0.1 ~ 40.63.255.254），广播地址：40.63.255.255B子网的网络地址：40.64.0.0/10，可用地址（40.64.0.1 ~ 40.127.255.254），广播地址：40.127.255.255C子网的网络地址：40.128.0.0/10，可用地址（40.128.0.1 ~ 40.191.255.254），广播地址：40.191.255.255D子网的网络地址：40.192.0.0/10，可用地址（40.192.0.1 ~ 40.255.255.254），广播地址：40.255.255.255 Ⅱ、变长子网划分VLSM规定了如何在一个进行了子网划分的网络中，不同子网使用不同的子网掩码。这对于网络内部不同网段需要不同大小子网的情形来说很有效，这种划分子网的方式叫变长子网划分。变长子网划分其实就是在等长子网的划分上，分别取不同等分子网中的某个或者多个子网。如上示例划分分析结果：A子网网络地址：192.168.10.32，255.255.255.224（/27），可用地址（192.168.10.33 ~ 192.168.10.62），广播地址：192.168.10.63相当于取了等长子网划分为8个子网中的一个子网 B子网网络地址：192.168.10.64，255.255.255.192（/26），可用地址（192.168.10.65 ~ 192.168.10.126），广播地址：192.168.10.127相当于取了等长子网划分为4个子网中的一个子网 C子网网络地址：192.168.10.128，255.255.255.128（/25），可用地址（192.168.10.129 ~ 192.168.10.254），广播地址：192.168.10.255相当于取了等长子网划分为2个子网中的一个子网 D子网网络地址：192.168.10.0，255.255.255.252（/30），可用地址（192.168.10.1 ~ 192.168.10.2），广播地址：192.168.10.3相当于取了等长子网划分为64个子网中的第一个子网 E子网网络地址：192.168.10.4，255.255.255.252（/30），可用地址（192.168.10.5 ~ 192.168.10.6），广播地址：192.168.10.7相当于取了等长子网划分为64个子网中的第二个子网2、变长子网划分总结①、变长子网划分规律如果一个子网地址块是原来网段的(1/2)^n，子网掩码就在原网段的基础上右移n位，不等长子网，子网掩码也不同。 ②、点到点网络的子网掩码每个子网是原来网络的(1/2)×(1/2)×(1/2)×(1/2)×(1/2)×(1/2)，也就是(1/2)^6，子网掩码往右移动6位。 例如：11111111.11111111.11111111.11111100写成十进制子网掩码也就是255.255.255.252。 四、子网划分总结和技巧 1、确定划分子网数子网数 = 2^n，n代表子网掩码往右移动的位数例如：要划分2个子网，子网掩码需要往右移动1位，2^1=2要划分4个子网，子网掩码需要往右移动2位，2^2=4要划分8个子网，子网掩码需要往右移动3位，2^3=8……子网数只能为2倍的关系划分。 2、确定子网划分后的地址每个子网地址块大小（IP_block）= 2^(8-n)每个子网可用地址个数（IP_num）= 2^(8-n)-2①、子网的网络地址 = 从0到255，取每段地址块的首个值②、子网的广播地址 = 下一个子网的网络地址-1③、子网的可用地址 = 子网的网络地址到子网的广播地址区间 例如：要划分为4个网段（2^2），子网掩码右移2位每个子网地址块大小（IP_block）= 2^(8-4) = 64每个子网可用地址个数（IP_num）= 2^(8-4)-2 = 62每段取值分别为：0，64，128，192第一个子网①、网络地址 = 0②、广播地址 = 63③、可用地址 = 1到62 第二个子网①、网络地址 = 64②、广播地址 = 127③、可用地址 = 65到126 第三个子网①、网络地址 = 128②、广播地址 = 191③、可用地址 = 129到190 第四个子网①、网络地址 = 192②、广播地址 = 255③、可用地址 = 193到254 3、确定子网掩码划分后的子网掩码CIDR = 原网络的子网掩码CIDR+n，如要写成十进制：256-2^(8-n)例如：原来子网掩码：255.255.255.0（/24），往右移动3位，则划分为8个子网子网掩码就变为为 /27，256-2^(8-3) = 256-2^5 = 256-32 = 224最后子网掩码结果：255.255.255.224（/27） 如还有不明白的，请参照上面给出的VLSM可变长子网掩码对应CIDR值这个图就一目了然。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>basic-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址和子网划分学习笔记之《子网掩码详解》]]></title>
    <url>%2F2019%2F09%2F27%2FIP%E5%9C%B0%E5%9D%80%E5%92%8C%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8A%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AF%A6%E8%A7%A3%E3%80%8B%2F</url>
    <content type="text"><![CDATA[知识结构:IP地址和子网划分学习笔记之《预备知识：进制计数》IP地址和子网划分学习笔记之《IP地址详解》IP地址和子网划分学习笔记之《子网掩码详解》IP地址和子网划分学习笔记之《子网划分详解》IP地址和子网划分学习笔记之《超网合并详解》 原文出处:https://blog.51cto.com/6930123/2112748 IP地址和子网划分学习笔记之《子网掩码详解》一、子网掩码IP地址是以网络号和主机号来标示网络上的主机的，我们把网络号相同的主机称之为本地网络，网络号不相同的主机称之为远程网络主机，本地网络中的主机可以直接相互通信；远程网络中的主机要相互通信必须通过本地网关（Gateway）来传递转发数据。 子网掩码的概念和作用①、子网掩码（Subnet Mask）又叫网络掩码、地址掩码，必须结合IP地址一起对应使用。②、只有通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。③、子网掩码和IP地址做“与”运算，分离出IP地址中的网络地址和主机地址，用于判断该IP地址是在本地网络上，还是在远程网络网上。④、子网掩码还用于将网络进一步划分为若干子网，以避免主机过多而拥堵或过少而IP浪费。 2、子网掩码的组成①、同IP地址一样，子网掩码是由长度为32位二进制数组成的一个地址。②、子网掩码32位与IP地址32位相对应，IP地址如果某位是网络地址，则子网掩码为1，否则为0。③、举个栗子：如：11111111.11111111.11111111.00000000 注：左边连续的1的个数代表网络号的长度，（使用时必须是连续的，理论上也可以不连续），右边连续的0的个数代表主机号的长度。 3、子网掩码的表示方法①、点分十进制表示法二进制转换十进制，每8位用点号隔开例如：子网掩码二进制11111111.11111111.11111111.00000000，表示为255.255.255.0 ②、CIDR斜线记法IP地址/n例1：192.168.1.100/24，其子网掩码表示为255.255.255.0，二进制表示为11111111.11111111.11111111.00000000例2：172.16.198.12/20，其子网掩码表示为255.255.240.0，二进制表示为11111111.11111111.11110000.00000000不难发现，例1中共有24个１，例2中共有20个１，所以n是这么来的。运营商ISP常用这样的方法给客户分配IP地址。 注：n为1到32的数字，表示子网掩码中网络号的长度，通过n的个数确定子网的主机数=2^(32-n)-2（-2的原因：主机位全为0时表示本网络的网络地址，主机位全为1时表示本网络的广播地址，这是两个特殊地址）。 4、为什么要使用子网掩码？前面说道，子网掩码可以分离出IP地址中的网络地址和主机地址，那为什么要分离呢？因为两台主机要通信，首先要判断是否处于同一网段，即网络地址是否相同。如果相同，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地。 可以这么简单的理解：A主机要与B主机通信，A和B各自的IP地址与A主机的子网掩码进行And与运算，看得出的结果：1、结果如果相同，则说明这两台主机是处于同一个网段，这样A可以通过ARP广播发现B的MAC地址，B也可以发现A的MAC地址来实现正常通信。2、如果结果不同，ARP广播会在本地网关终结，这时候A会把发给B的数据包先发给本地网关，网关再根据B主机的IP地址来查询路由表，再将数据包继续传递转发，最终送达到目的地B。计算机的网关（Gateway）就是到其他网段的出口，也就是路由器接口IP地址。路由器接口使用的IP地址可以是本网段中任何一个地址，不过通常使用该网段的第一个可用的地址或最后一个可用的地址，这是为了尽可能避免和本网段中的主机地址冲突。 在如下拓扑图示例中，A与B，C与D，都可以直接相互通信（都是属于各自同一网段，不用经过路由器），但是A与C，A与D，B与C，B与D它们之间不属于同一网段，所以它们通信是要经过本地网关，然后路由器根据对方IP地址，在路由表中查找恰好有匹配到对方IP地址的直连路由，于是从另一边网关接口转发出去实现互连。 5、子网掩码的分类①、缺省子网掩码 也叫默认子网掩码，即未划分子网，对应的网络号的位都置 1 ，主机号都置 0 。 未做子网划分的IP地址：网络号＋主机号A类网络缺省子网掩码： 255.0.0.0，用CIDR表示为/8B类网络缺省子网掩码： 255.255.0.0，用CIDR表示为/16C类网络缺省子网掩码： 255.255.255.0，用CIDR表示为/24 ②、自定义子网掩码 将一个网络划分子网后，把原本的主机号位置的一部分给了子网号，余下的才是给了子网的主机号。其形式如下：做子网划分后的IP地址：网络号＋子网号＋子网主机号 举个栗子：如：192.168.1.100/25，其子网掩码表示：255.255.255.128意思就是将192.168.1.0这个网段的主机位的最高1位划分为了子网。关于子网划分将在下篇文章讲到，这里不在阐述。 6、子网掩码和IP地址的关系子网掩码是用来判断任意两台主机的IP地址是否属于同一网络的依据，就是拿双方主机的IP地址和自己主机的子网掩码做与运算，如结果为同一网络，就可以直接通信。 And按位与运算：与运算是计算机中一种基本的逻辑运算方式，符号表示为&amp;，也可以表示为 and。参加运算的两个数据，按二进制位进行“与”运算。运算规则：0&amp;0=0；0&amp;1=0；1&amp;0=0；1&amp;1=1；即：两位同时为“1”，结果才为“1”，否则为0 如何根据IP地址和子网掩码，计算网络地址： ①、将IP地址与子网掩码转换成二进制数。②、将二进制形式的 IP 地址与子网掩码做“与”运算。③、将得出的结果转化为十进制，便得到网络地址。如下图： 网络地址计算小技巧：IP地址和子网掩码做与运算，把IP地址的主机位直接归0，就快速得到网络地址。所以只要一看到IP地址和子网掩码，就能马上确认网络地址。 二、CIDR与VLSM理解和掌握了子网掩码这部分知识后，这里要补充下CIDR和VLSM，这对于我们下篇讲述的子网划分，简直了就是放大招啊！ 1、有类和无类网络，超网和子网我们先了解这几个概念，对于CIDR和VLSM以及子网划分都是很有用的。 ◆ 有类网络：也叫主类网络或标准网络，就是指把IP地址能归结到的A类、B类、C类IP，使用的是标准的默认子网掩码。 ◆ 无类网络：相对于有类网络，无类网络IP地址的掩码是变长的。在有类网络的基础上，拿出一部分主机ID作为子网ID。 ◆ 超网：把多个小网络组合成一个大网络，称为超网（SuperNetting），也可以说子网掩码长度小于相对应的有类网络的叫超网。 ◆ 子网：有类网络划分成更小后的网络，称为子网（Subnet），也可以说子网掩码长度大于相对应的有类网络的叫子网。 2、CIDR无类别域间路由CIDR（Classless Inter-Domain Routing，无类别域间路由）本质是消除了传统的A类、B类和C类地址以及划分子网的概念，将多个地址块聚合在一起生成一个更大的网络，从而包含更多的主机。 CIDR采用8-30位可变网络ID（最大可用的只能为30位，即保留2位给主机位），而不是A、B、C类网络ID所用的固定的8、16和24位。CIDR表示方法：IP地址/n，n表示IP地址中的前n位代表网络部分（n个二进制数1），其余（32-n）位代表主机部分。这种方法称为“斜线记法”，它又称为CIDR记法。 举个栗子：子网掩码255.255.255.192，用CIDR表示是多少呢？ ①、首先确认的是这是个C类网络地址（C类的默认子网掩码为255.255.255.0） ②、前面三个字节都是255，转换成二进制都为1，即11111111.11111111.11111111，即24位1。 ③、后面一个字节是192，转换成二进制为11000000，即1占用了2位。 ④、子网掩码共占用了26位1，所以用CIDR表示为/26。 ⑤、如果网络地址为192.168.10.0，再加上CIDR，最后表示为192.168.10.0/26。 CIDR支持路由聚合，能够将路由表中的许多路由条目合并为成更少的数目，因此可以限制路由器中路由表的增大，减少路由通告，减轻路由器的负担。 3、VLSM可变长子网掩码VLSM（Variable Length Subnet Mask，可变长子网掩码）规定了在一个有类（A、B、C类）网络内包含多个子网掩码的能力，以及对一个子网的再进行子网划分的能力。 每一个IP地址都包含了2部分：网络号和主机号。在有类网络中，32bit的IP地址被分为4段，每段8bit来表示。这使得作为网络号的前缀必须是8位，16位或者24位。当网络号是24位的时候，主机号只有8位，也就是说，可分配的最小的地址块是256个（2^8=256，而实际可分配的主机地址还要减去两个，一个是网络地址，一个是广播地址，最后为254个），这个数量对于大多数企业来说是不够的。 而比这个大一点的IP地址块是网络号为16位的时候，这个时候可分配的地址块是65536（2^16=65536），这个数量对于大多数公司又太多了。这导致无论公司选择哪种类型的网络，都可能对IP地址造成大量的浪费。 IP地址如果只使用有类（A、B、C类）来划分，会造成大量的浪费或者不够用。VLSM的诞生有效的解决了这个问题，可以在有类网络的基础上，通过对IP地址的主机号进行再划分，把一部分划入网络号，就能划分各种类型大小的网络了。网络号也不再仅局限在8、16和24位这几个数，而是灵活变化的大小了。 4、CIDR与VLSM的区别在使用CIDR聚合地址时，将原来有类IP地址中的网络位划出一部分作为主机位使用。在使用VLSM划分子网时，将原来有类IP地址中的主机位按照需要划出一部分作为网络位使用。CIDR：子网掩码往左边移，掩码netmask缩短了。VLSM：子网掩码往右边移，掩码netmask增长了。 注意，其实这里是相对的，举个栗子一个公司假定子网掩码255.255.0.0采用CIDR就是向左移VLSM向右移，可以划分大于16小于24位的网络掩码 CIDR是把几个有类网络合成一个大的网络（超网），用于路由地址聚合。VLSM是把一个有类网络分成几个小型网络（子网），用于更高效划分子网。 CIDR与VLSM总结：在某种程度上来说，CIDR和VLSM它们之间可以看做是逆过程。CIDR是把几个小网络聚合成一个大网络来做表示，而VLSM则是把一个大网络继续细分为几个小网络进行IP地址分配。CIDR能让路由器的路由条目得到有效的减少，从而减少路由通告，降低路由器负担，而VLSM则是充分利用IP进行地址分配来解决IP地址不被浪费的问题，节约IP地址空间，更为有效的使用。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>basic-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址和子网划分学习笔记之《IP地址详解》]]></title>
    <url>%2F2019%2F09%2F25%2FIP%E5%9C%B0%E5%9D%80%E5%92%8C%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E3%80%8AIP%E5%9C%B0%E5%9D%80%E8%AF%A6%E8%A7%A3%E3%80%8B%2F</url>
    <content type="text"><![CDATA[知识结构:IP地址和子网划分学习笔记之《预备知识：进制计数》IP地址和子网划分学习笔记之《IP地址详解》IP地址和子网划分学习笔记之《子网掩码详解》IP地址和子网划分学习笔记之《子网划分详解》IP地址和子网划分学习笔记之《超网合并详解》 原文出处: https://blog.51cto.com/6930123/2112403 一、IP地址和MAC地址1、MAC地址MAC（Media Access Control，介质访问控制）地址，或称为物理地址，也叫硬件地址，用来定义网络设备的位置，MAC地址是网卡出厂时设定的，是固定的（但可以通过在设备管理器中或注册表等方式修改，同一网段内的MAC地址必须唯一）。MAC地址采用十六进制数表示，长度是6个字节（48位），分为前24位和后24位。 1、前24位叫做组织唯一标志符（Organizationally Unique Identifier，即OUI），是由IEEE的注册管理机构给不同厂家分配的代码，区分了不同的厂家。2、后24位是由厂家自己分配的，称为扩展标识符。同一个厂家生产的网卡中MAC地址后24位是不同的。 MAC地址对应于OSI参考模型的第二层数据链路层，工作在数据链路层的交换机维护着计算机MAC地址和自身端口的数据库，交换机根据收到的数据帧中的“目的MAC地址”字段来转发数据帧。 2、IP地址IP地址（Internet Protocol Address），缩写为IP Adress，是一种在Internet上的给主机统一编址的地址格式，也称为网络协议（IP协议）地址。它为互联网上的每一个网络和每一台主机分配一个逻辑地址，常见的IP地址，分为IPv4与IPv6两大类，当前广泛应用的是IPv4，目前IPv4几乎耗尽，下一阶段必然会进行版本升级到IPv6；如无特别注明，一般我们讲的的IP地址所指的是IPv4。 IP地址对应于OSI参考模型的第三层网络层，工作在网络层的路由器根据目标IP和源IP来判断是否属于同一网段，如果是不同网段，则转发数据包。 3、IP地址格式和表示 在计算机二进制中，1个字节 = 8位 = 8bit（比特）IP地址(IPv4)由32位二进制数组成，分为4段（4个字节），每一段为8位二进制数（1个字节）每一段8位二进制，中间使用英文的标点符号“.”隔开 ①IP地址格式和表示IP地址(IPv4)由32位二进制数组成，分为4段（4个字节），每一段为8位二进制数（1个字节）每一段8位二进制，中间使用英文的标点符号“.”隔开 由于二进制数太长，为了便于记忆和识别，把每一段8位二进制数转成十进制，大小为0至255。IP地址的这种表示法叫做“点分十进制表示法”。IP地址表示为：xxx.xxx.xxx.xxx举个栗子：210.21.196.6就是一个IP地址的表示。 ②理解2的指数幂2的幂也称为2的指数，还可以称为2的次方，如2的2次方、2的3次方等等，任何数的0次方都等于1。在IP地址中，0次方到7次方刚好为8位，这对于IP地址二进制转换为十进制非常方便。举个栗子：11010010 = 1×2^7+1×2^6+0×2^5+1×2^4+0×2^3+0×2^2+1×2^1+0×2^0 = 128+64+0+16+0+0+2+0 = 210 我们需要记住上图的2的幂的结果，不需要死记硬背，这个是有技巧的，从上图来看，很容易发现，由于是2的幂，所有相邻的幂的前后都是相差2倍，所以只要知道其中一个幂值，就知道相邻的幂的值。 4、IP地址的组成IP地址=网络地址+主机地址，比如：计算机的IP地址由两部分组成，一部分为网络标识，一部分为主机标识，同一网段内的计算机网络部分相同，主机部分不同且不能重复出现。路由器连接不同网段，负责不同网段之间的数据转发，交换机连接的是同一网段的计算机。通过设置网络地址和主机地址，在互相连接的整个网络中保证每台主机的IP地址不会互相重叠，即IP地址具有了唯一性。 5、IP地址与MAC地址区别 长度不同：IP地址为32位（二进制），MAC地址为48位（十六进制）。 分配依据不同：IP地址的分配是基于网络拓扑，MAC地址的分配是基于制造商。 寻址协议层不同：IP地址应用于OSI第三层（网络层），而MAC地址应用在OSI第二层（数据链路层）。 6、IP地址与MAC地址的作用和关系IP和MAC两者之间分工明确，默契合作，完成通信过程。在数据通信时，IP地址专注于网络层，网络层设备（如路由器）根据IP地址，将数据包从一个网络传递转发到另外一个网络上；而MAC地址专注于数据链路层，数据链路层设备（如交换机）根据MAC地址，将一个数据帧从一个节点传送到相同链路的另一个节点上。IP和MAC地址这种映射关系由ARP（Address Resolution Protocol，地址解析协议）协议完成，ARP根据目的IP地址，找到中间节点的MAC地址，通过中间节点传送，从而最终到达目的网络。 计算机在和其他计算机通信之前，首先要判断目标IP地址和自己的IP地址是否在一个网段，这决定了数据链层的目标MAC地址是目标计算机的还是路由器接口的MAC地址。数据包的目标IP地址决定了数据包最终到达哪一个计算机，而目标MAC地址决定了该数据包下一跳由哪个设备接收，不一定是终点。 二、IP地址的分类1、IP地址分类详解IP地址分A、B、C、D、E五类，其中A、B、C这三类是比较常用的IP地址，D、E类为特殊地址。①、A类地址A类地址第1字节为网络地址（最高位固定是0），另外3个字节为主机地址。A类地址范围：1.0.0.0 - 126.255.255.255，其中0和127作为特殊地址。A类网络默认子网掩码为255.0.0.0，也可写作/8。A类网络最大主机数量是256×256×256-2=166777214（减去1个主机位为0的网络地址和1个广播地址）。 在计算机网络中，主机ID全部为0的地址为网络地址，而主机ID全部为1的地址为广播地址，这2个地址是不能分配给主机用的。 ②、B类地址B类地址第1字节（最高位固定是10）和第2字节为网络地址，另外2个字节为主机地址。B类地址范围：128.0.0.0 - 191.255.255.255。B类网络默认子网掩码为255.255.0.0，也可写作/16。B类网络最大主机数量256×256-2=6554。③、C类地址C类地址第1字节（最高位固定是110）、第2字节和第3个字节，另外1个字节为主机地址。C类地址范围：192.0.0.0 - 223.255.255.255。C类网络默认子网掩码为255.255.255.0，也可写作/24。C类网络最大主机数量256-2=254。 ④、D类地址D类地址不分网络地址和主机地址，它的第1个字节的最高位固定是1110。D类地址用于组播（也称为多播）的地址，无子网掩码。D类地址范围：224.0.0.0 - 239.255.255.255。⑤、E类地址E类地址也不分网络地址和主机地址，它的第1个字节的最高位固定是11110。E类地址范围：240.0.0.0 - 255.255.255.255。其中240.0.0.0-255.255.255.254作为保留地址，主要用于Internet试验和开发，255.255.255.255作为广播地址。 2、IP地址分类思维导图IP地址总结学习思维导图如下 三、保留的特殊IP地址以下这些特殊IP地址都是不能分配给主机用的地址： 主机ID全为0的地址：特指某个网段，比如：192.168.10.0 255.255.255.0，指192.168.10.0网段。 主机ID全为1的地址：特指该网段的全部主机，比如：192.168.10.255，如果你的计算机发送数据包使用主机ID全是1的IP地址，数据链层地址用广播地址FF-FF-FF-FF-FF-FF。 127.0.0.1：是本地环回地址，指本机地址，一般用来测试使用。回送地址(127.x.x.x)是本机回送地址(Loopback Address)，即主机IP堆栈内部的IP地址。 169.254.0.0：169.254.0.0-169.254.255.255实际上是自动私有IP地址。 0.0.0.0：如果计算机的IP地址和网络中的其他计算机地址冲突，使用ipconfig命令看到的就是0.0.0.0，子网掩码也是0.0.0.0。保留的特殊IP地址思维导图如下： 四、公网和私网IP地址公网IP地址公有地址分配和管理由Inter NIC（Internet Network Information Center 因特网信息中心）负责。各级ISP使用的公网地址都需要向Inter NIC提出申请，有Inter NIC统一发放，这样就能确保地址块不冲突。 私网IP地址创建IP寻址方案的人也创建了私网IP地址。这些地址可以被用于私有网络，在Internet没有这些IP地址，Internet上的路由器也没有到私有网络的路由表。 A类：10.0.0.0 255.0.0.0，保留了1个A类网络。 B类：172.16.0.0 255.255.0.0～172.31.0.0 255.255.0.0，保留了16个B类网络。 C类：192.168.0.0 255.255.255.0～192.168.255.0 255.255.255.0，保留了256个C类网络。PS：私网地址访问Internet需要做NAT或PAT网络地址转换公网和私网IP地址思维导图如下 参考资料:IP地址和子网划分学习笔记之《IP地址详解》]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>basic-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络层次划分]]></title>
    <url>%2F2019%2F09%2F24%2F%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E5%88%92%E5%88%86%2F</url>
    <content type="text"><![CDATA[[转载]计算机网络基础知识总结 1.网络层次划分为了使不同计算机厂家生产的计算机能够相互通信，以便在更大的范围内建立计算机网络，国际标准化组织（ISO）在1978年提出了“开放系统互联参考模型”，即著名的OSI/RM模型（Open System Interconnection/Reference Model）。它将计算机网络体系结构的通信协议划分为七层，自下而上依次为：物理层（Physics Layer）、数据链路层（Data Link Layer）、网络层（Network Layer）、传输层（Transport Layer）、会话层（Session Layer）、表示层（Presentation Layer）、应用层（Application Layer）。其中第四层完成数据传送服务，上面三层面向用户。 除了标准的OSI七层模型以外，常见的网络层次划分还有TCP/IP四层协议以及TCP/IP五层协议，它们之间的对应关系如下图所示： 2.OSI七层网络模型TCP/IP协议毫无疑问是互联网的基础协议，没有它就根本不可能上网，任何和互联网有关的操作都离不开TCP/IP协议。不管是OSI七层模型还是TCP/IP的四层、五层模型，每一层中都要自己的专属协议，完成自己相应的工作以及与上下层级之间进行沟通。由于OSI七层模型为网络的标准层次划分，所以我们以OSI七层模型为例从下向上进行一一介绍。 1）物理层（Physical Layer）激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性以及过程特性。该层为上层协议提供了一个传输数据的可靠的物理媒体。简单的说，物理层确保原始的数据可在各种物理媒体上传输。物理层记住两个重要的设备名称，中继器（Repeater，也叫放大器）和集线器 2）数据链路层（Data Link Layer） 数据链路层在物理层提供的服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据可靠地传输到相邻节点的目标机网络层。为达到这一目的，数据链路必须具备一系列相应的功能，主要有：如何将数据组合成数据块，在数据链路层中称这种数据块为帧（frame），帧是数据链路层的传送单位；如何控制帧在物理信道上的传输，包括如何处理传输差错，如何调节发送速率以使与接收方相匹配；以及在两个网络实体之间提供数据链路通路的建立、维持和释放的管理。数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。 有关数据链路层的重要知识点： 1&gt; 数据链路层为网络层提供可靠的数据传输； 2&gt; 基本数据单位为帧； 3&gt; 主要的协议：以太网协议； 4&gt; 两个重要设备名称：网桥和交换机。 3）网络层（Network Layer） 网络层的目的是实现两个端系统之间的数据透明传送，具体功能包括寻址和路由选择、连接的建立、保持和终止等。它提供的服务使传输层不需要了解网络中的数据传输和交换技术。如果您想用尽量少的词来记住网络层，那就是“路径选择、路由及逻辑寻址”。 网络层中涉及众多的协议，其中包括最重要的协议，也是TCP/IP的核心协议——IP协议。IP协议非常简单，仅仅提供不可靠、无连接的传送服务。IP协议的主要功能有：无连接数据报传输、数据报路由选择和差错控制。与IP协议配套使用实现其功能的还有地址解析协议ARP、逆地址解析协议RARP、因特网报文协议ICMP、因特网组管理协议IGMP。具体的协议我们会在接下来的部分进行总结，有关网络层的重点为： 1&gt; 网络层负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能； 2&gt; 基本数据单位为IP数据报； 3&gt; 包含的主要协议： IP协议（Internet Protocol，因特网互联协议）; ICMP协议（Internet Control Message Protocol，因特网控制报文协议）; ARP协议（Address Resolution Protocol，地址解析协议）; RARP协议（Reverse Address Resolution Protocol，逆地址解析协议）。 4&gt; 重要的设备：路由器 4）传输层（Transport Layer） 第一个端到端，即主机到主机的层次。传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。 传输层的任务是根据通信子网的特性，最佳的利用网络资源，为两个端系统的会话层之间，提供建立、维护和取消传输连接的功能，负责端到端的可靠数据传输。在这一层，信息传送的协议数据单元称为段或报文。 网络层只是根据网络地址将源结点发出的数据包传送到目的结点，而传输层则负责将数据可靠地传送到相应的端口。 有关网络层的重点： 1&gt; 传输层负责将上层数据分段并提供端到端的、可靠的或不可靠的传输以及端到端的差错控制和流量控制问题； 2&gt; 包含的主要协议：TCP协议（Transmission Control Protocol，传输控制协议）、UDP协议（User Datagram Protocol，用户数据报协议）； 3&gt; 重要设备：网关。 5）会话层 会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。会话层还利用在数据中插入校验点来实现数据的同步。 6）表示层 表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。 7）应用层 为操作系统或网络应用程序提供访问网络服务的接口。 会话层、表示层和应用层重点： 1&gt; 数据传输基本单位为报文； 2&gt; 包含的主要协议：FTP（文件传送协议）、Telnet（远程登录协议）、DNS（域名解析协议）、SMTP（邮件传送协议），POP3协议（邮局协议），HTTP协议（Hyper Text Transfer Protocol）。 参考:BugBank]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>basic-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html study]]></title>
    <url>%2F2019%2F09%2F18%2Fhtml-study%2F</url>
    <content type="text"><![CDATA[html快速学习语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152一、文字 1.标题文字 &lt;h#&gt;..........&lt;/h#&gt; #=1~6；h1为最大字，h6为最小字 2.字体变化 &lt;font&gt;..........&lt;/font&gt; 【1】字体大小 &lt;font size=#&gt;..........&lt;/font&gt; #=1~7；数字愈大字也愈大 【2】指定字型 &lt;font face=&quot;字体名称&quot;&gt;..........&lt;/font&gt; 【3】文字颜色 &lt;font color=#rrggbb&gt;..........&lt;/font&gt; rr：表红色（red）色码 gg：表绿色（green）色码 bb：表蓝色（blue）色码 rrggbb也可用6位颜色代码数字 3.显示小字体 &lt;small&gt;..........&lt;/small&gt; 4.显示大字体 &lt;big&gt;..........&lt;/big&gt; 5.粗体字 &lt;b&gt;..........&lt;/b&gt; 6.斜体字 &lt;i&gt;..........&lt;/i&gt; 7.打字机字体 &lt;tt&gt;..........&lt;/tt&gt; 8.底线 &lt;u&gt;..........&lt;/u&gt; 9.删除线 &lt;strike&gt;..........&lt;/strike&gt; 10.下标字 &lt;sub&gt;..........&lt;/sub&gt; 11.上标字 &lt;sup&gt;..........&lt;/sup&gt; 12.文字闪烁效果 &lt;blink&gt;..........&lt;/blink&gt; 13.换行（也称回车） &lt;br&gt; 14.分段 &lt;p&gt; 15.文字的对齐方向 &lt;p align=&quot;#&quot;&gt; #号可为 left：表向左对齐（预设值） center：表向中对齐 right：表向右对齐 P.S.&lt;p align=&quot;#&quot;&gt;之后的文字都会以所设的对齐方式显示，直到出现另一个&lt;p align=&quot;#&quot;&gt;改变其对齐方向，遇到&lt;hr&gt;或&lt;h#&gt;标签时会自动设回预设的向左对齐。 16.分隔线 &lt;hr&gt; 【1】分隔线的粗细 &lt;hr size=点数&gt; 【2】分隔线的宽度 &lt;hr size=点数或百分比&gt; 【3】分隔线对齐方向 &lt;hr align=&quot;#&quot;&gt; #号可为 left：表向左对齐（预设值） center：表向中对齐 right：表向右对齐 【4】分隔线的颜色 &lt;hr color=#rrggbb&gt; 【5】实心分隔线 &lt;hr noshade&gt; 17.居中对齐 &lt;center&gt;..........&lt;/center&gt; 18.依原始样式显示 &lt;pre&gt;..........&lt;/pre&gt; 19.&lt;body&gt;指令的属性 【1】背景颜色 -- bgcolor &lt;body bgcolor=#rrggbb&gt; 【2】背景图案 -- background &lt;body background=&quot;图形文件名&quot;&gt; 【3】设定背景图案不会卷动 -- bgproperties &lt;body bgproperties=fixed&gt; 【4】文件内容文字的颜色 -- text &lt;body text=#rrggbb&gt; 【5】超连结文字颜色 -- link &lt;body link=#rrggbb&gt; 【6】正被选取的超连结文字颜色 -- vlink &lt;body vlink=#rrggbb&gt; 【7】已连结过的超连结文字颜色 -- alink &lt;body alink=#rrggbb&gt; 20.文字移动指令&lt;MARQUEE&gt;..........&lt;/MARQUEE&gt; 移动速度指令是:scrollAmount=# #最小为1，速度为最慢；数字越大移动的越快。 移动方向指令是：direction=# up向上、down向下、left向左、right向右。 指令举例：&lt;MARQUEE scrollAmount=3 direction=up&gt;..........&lt;/MARQUEE&gt; 二、图片 1.插入图片 &lt;img src=&quot;图形文件名&quot;&gt; 2.设定图框 -- border &lt;img src=&quot;图形文件名&quot; border=点数&gt; 3.设定图形大小 -- width、height &lt;img src=&quot;图形文件名&quot; width=宽度点数 height=高度点数&gt; 4.设定图形上下左右留空 -- vspace、hspace &lt;img src=&quot;图形文件名&quot; vspace=上下留空点数 hspace=左右留空点数&gt; 5.图形附注 &lt;img src=&quot;图形文件名&quot; alt=&quot;说明文字&quot;&gt; 6.预载图片 &lt;img src=&quot;高解析度图形文件名&quot; lowsrc=&quot;低解析度图形文件名&quot;&gt; P.S.两个图的图形大小最好一致; 7.影像地图（Image Map） &lt;img src=&quot;图形文件名&quot; usemap=&quot;#图的名称&quot;&gt; &lt;map name=&quot;图的名称&quot;&gt; &lt;area shape=形状 coords=区域座标列表 href=&quot;连结点之URL&quot;&gt; &lt;area shape=形状 coords=区域座标列表 href=&quot;连结点之URL&quot;&gt; &lt;area shape=形状 coords=区域座标列表 href=&quot;连结点之URL&quot;&gt; &lt;area shape=形状 coords=区域座标列表 href=&quot;连结点之URL&quot;&gt; &lt;/map&gt; 【1】定义形状 -- shape shape=rect：矩形 shape=circle：圆形 shape=poly：多边形 【2】定义区域 -- coords a.矩形：必须使用四个数字，前两个数字为左上角座标，后两个数字为右下角座标 例：&lt;area shape=rect coords=100,50,200,75 href=&quot;URL&quot;&gt; b.圆形：必须使用三个数字，前两个数字为圆心的座标，最后一个数字为半径长度 例：&lt;area shape=circle coords=85,155,30 href=&quot;URL&quot;&gt; c.任意图形（多边形）：将图形之每一转折点座标依序填入 例：&lt;area shape=poly coords=232,70,285,70,300,90,250,90,200,78 href=&quot;URL&quot; 三、表格相关 1.表格标题 &lt;caption&gt;..........&lt;/caption&gt; 表格标题位置 -- align &lt;caption align=&quot;#&quot;&gt; #号可为 top：表标题置于表格上方（预设值） bottom：表标题置于表格下方 2.定义列 &lt;tr&gt; 3.定义栏位 《1》&lt;td&gt;：靠左对齐 《2》&lt;th&gt;：靠中对齐ⅱ粗体 【1】水平位置 -- align &lt;th align=&quot;#&quot;&gt; #号可为 left：向左对齐 center：向中对齐 right：向右对齐 【2】垂直位置 -- align &lt;th align=&quot;#&quot;&gt; #号可为 top：向上对齐 middle：向中对齐 bottom：向下对齐 【3】栏位宽度 -- width &lt;th width=点数或百分比&gt; 【4】栏位垂直合并 -- rowspan &lt;th rowspan=欲合并栏位数&gt; 【5】栏位横向合并 -- colspan &lt;th colspan=欲合并栏位数&gt; 四、表格的主要属性 1. &lt;table&gt;标记的主要属性 align定义表格的对齐方式，有三个属性值center，left，right background定义表格的背景图案，属性值为图片的地址 bgcolor定义表格的背景颜色，属性值是各种颜色代码 border定义表格的边框宽度，属性值是数字 bordercolor定义表格边框的颜色，属性值是各种颜色代码 cellpadding定义单元格内容与单元格边框之间的距离，属性值是数字 cellspacing定义表格中单元格之间的距离 height定义表格的高度，属性值是数字 width定义表格的宽度，属性值是数字 2. &lt;tr&gt;标记，表格是由多行与多列组成的，&lt;tr&gt;标记用来定义表格的一行，他的属性极其属性值定义的是表格中的该行，其主要属性与属性值如下： align定义对齐方式，属性值与上同 background定义背景图案 bgcolor定义背景色 3. &lt;td&gt;标记。用&lt;td&gt;标记概况起来的内容表示表格的单元。其主要属性与属性值和&lt;table&gt;标记的一样，补充两个合并列和行的代码： colspan定义合并表格的列数，属性值是数字 rowspan定义合并表格的行数，属性值是数字 五、FRAME 1、分割视窗指令 &lt;frameset&gt;..........&lt;/frameset&gt; 【1】垂直（上下）分割 -- rows &lt;frameset rows=#&gt; #号可为点数： 如欲分割为100,200,300三个视窗，则&lt;frameset rows=100,200,300&gt;； 亦可以*号代表，如&lt;frameset rows=*,500,*&gt; 百分比：如&lt;frameset rows=30%,70%&gt;，各项总和最好为100%; 【2】水平（左右）分割 -- cols &lt;frameset cols=点数或百分比&gt; 2、指定视窗内容 -- &lt;frame&gt; &lt;frameset cols=30%,70%&gt; &lt;frame&gt; &lt;frame&gt; &lt;/frameset&gt; 【1】指定视窗的文件名称 -- src &lt;frame src=HTML档名&gt; 【2】定义视窗的名称 -- name &lt;frame name=视窗名称&gt; 【3】设定文件与上下边框的距离 -- marginheight &lt;frame marginheight=点数&gt; 【4】设定文件与左右边框的距离 -- marginwidth &lt;frame marginwidth=点数&gt; 【5】设定分割视窗卷轴 -- scrolling &lt;frame scrolling=#&gt; #号可为 yes：固定出现卷轴 no：不出现卷轴 auto：自动判断文件大小需不需要卷轴（预设值） 【6】锁住分割视窗的大小 -- noresize &lt;frame noresize&gt; 六、歌曲代码: 在这组代码中，不必管它是mms.http.rtsp，只要看尾缀是asf、wma、wmv、wmv、rm都可适用下面的代码: 1. 手动播放: &lt;EMBED src=歌曲地址 volume=&quot;100&quot; width=39 height=18 hidden=&quot;FALSE&quot; autostart=&quot;fault&quot; type=&quot;audio/x-pn-realaudio-plugin&quot; controls=&quot;PlayButton&quot;&gt; 2. 打开页面自动播放: &lt;EMBED src=&quot;歌曲地址&quot; width=&quot;39&quot; height=&quot;18&quot; autostart=&quot;true&quot; hidden=&quot;false&quot; loop=&quot;infinite&quot; align=&quot;middle&quot; volume=&quot;100&quot; type=&quot;audio/x-pn-realaudio-plugin&quot; controls=&quot;PlayButton&quot; autostart=&quot;true&quot;&gt; ------------------------------------------------------------------ 套用代码: &lt;div align=&quot;center&quot;&gt; &lt;table border=&quot;1&quot; width=&quot;90%&quot; height=&quot;403&quot; background=&quot;背景图片地址&quot;&gt; &lt;tr&gt;&lt;td width=&quot;80%&quot; height=&quot;100%&quot;&gt; &lt;p align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;font face=&quot;华文彩云&quot; size=&quot;6&quot; color=&quot;#FFFFFF&quot;&gt;歌曲或音乐名称&lt;/font&gt;&lt;br&gt;&lt;br&gt; &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;图片地址&quot;&gt;&lt;br&gt;&lt;br&gt; &lt;font color=&quot;#FFFFFF&quot; size=3&gt;介绍文字&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;EMBED style=&quot;FILTER: xray()&quot; src=音乐地址 width=250 height=30 type=audio/x-ms-wma autostart=&quot;true&quot; loop=&quot;-1&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; &lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; &lt;/div&gt; 简易套用代码详解: &lt;div align=&quot;center&quot;&gt;是定义帖子居中; &lt;table border=&quot;1&quot; width=&quot;90%&quot; height=&quot;403&quot; background=&quot;背景图片地址&quot;&gt;&lt;tr&gt;&lt;td width=&quot;80%&quot; height=&quot;100%&quot;&gt; 这其中的border=&quot;1&quot;是定义表格边线的宽度,定义为0则无边线;width=&quot;90%&quot; height=&quot;403&quot;分别定义背景图表格的宽度和高度.如果背景图是一张大图,可以这样定义:width=图片宽度 height=图片高度 &lt;p align=&quot;center&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;font face=&quot;华文彩云&quot; size=&quot;6&quot; color=&quot;#FFFFFF&quot;&gt;歌曲或音乐名称&lt;/font&gt;&lt;br&gt;&lt;br&gt; &lt;p align=&quot;center&quot;&gt;是定义文字居中的，&lt;br&gt;是回行代码，加几个就会空几行。&lt;font face=&quot;华文彩云&quot; size=&quot;6&quot; color=&quot;#FFFFFF&quot;&gt;是定义文字属性的。face=&quot;华文彩云&quot;是定义字体，你可以把字体换成隶书、宋体等。size=&quot;6&quot;是定义字号的，数字越大字越大，如果不定义，默认是2号字。color=&quot;#FFFFFF&quot;是定义字体颜色的。全部字体颜色的代码在妙手饰图区有人发过，你可以找来改。 &lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;图片地址&quot;&gt;&lt;br&gt;&lt;br&gt;&lt;font color=&quot;#FFFFFF&quot;&gt;介绍文字&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt; 第一个括号里的代码仍然是定义图片和文字居中的。&lt;img src=&quot;图片地址&quot;&gt;是插入图片代码。&lt;font color=&quot;#FFFFFF&quot; size=3&gt;介绍文字&lt;/font&gt;是定义这段文字的。如果想改变字拧⒆痔濉⒆值难丈??烧瞻嵘厦嫖医驳亩ㄒ宸椒ā?/font&gt; &lt;EMBED style=&quot;FILTER: xray()&quot; src=音乐地址 width=250 height=30 type=audio/x-ms-wma autostart=&quot;true&quot; loop=&quot;-1&quot;&gt; 这一段是插入播放器代码，因为我插的是特殊的播放器，style=&quot;FILTER: xray()&quot; 是特殊代码。“src=音乐地址”是插入音乐文件的地址。width=250 height=30分别定义播放器的宽度和高度(如果把宽和高都设成零则为隐藏,并且只能自动播放)。autostart=&quot;true&quot; loop=&quot;-1&quot;是定义音乐播放方式的，autostart=&quot;true&quot;是设定手动或自动播放，“true”或“1”是自动播放，“false”或“0”是手动播放；loop=&quot;-1&quot;是播放次数，“true”或“1”表示重复播放，“false”“-1”或“0”是只播放一次。 &lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/div&gt;回行代码和与前面对应的固定代码。 参考:SKILLS小管家]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>basic-web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用hexo和github搭建博客]]></title>
    <url>%2F2019%2F09%2F12%2F%E5%88%A9%E7%94%A8hexo%E5%92%8Cgithub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[利用hexo和github搭建博客 前言之前一直想搭建自己的博客，忙活了半天，根据前人的教程，最终成功搭建一个雏形 前期准备下载并安装node.js (https://nodejs.org/en/)下载并安装git (https://git-scm.com/) 安装hexo，可能需要翻墙，所以可以先设置源，*npm config set registry https://registry.npm.taobao.org * 下载并安装hexo (需要先下载node.js，cmd –&gt; npm install -g hexo ) 安装找一个方便的目录，单独创建一个文件，我的目录如图 1234E: --MyBlog -- MyBlog（博客目录） -- Tools(上边的工具目录，Node.js等) 进入MyBlog目录，右键 –&gt; git bash –&gt; 输入hexo init (生成hexo模板) 之后再输入npm install 最后运行hexo server (测试运行，通过访问localhost:4000可以看到雏形) 运行浏览器，输入localhost:4000 与github关联首先Create a new repository填入repository name格式为.github.io打开之前的MyBlog文件夹下的_config.yml配置文件，将其中的type设置为git注意 冒号后边要跟空格 1234deploy: type: git repository: https://github.com/&lt;username&gt;/&lt;username&gt;.github.io.git branch: master 在bash中运行: npm install hexo-deployer-git –save运行: hexo clean (清空缓冲）运行：hexo g（本地生成静态文件）运行：hexo d（将本地静态文件推送至Github） 打开浏览器: 访问 http://.github.io 关联域名首先在域名中添加解析然后打开本地文件MyBlog中的source文件夹中创建CNAME文件，写入你的域名 bash 运行 hexo clean &amp;&amp;hexo g -d此时浏览器输入你的域名即可访问 博客的迁移第一台电脑具体步骤如下克隆.github.io到本地git clone 进入该response之后删除除了.git的全部文件,将Myblog所有文件拷贝到该目录下创建分支并切换为 hexogit checkout -b hexogit add . 把工作区的变化提交到暂存区git commit -m “hexo” 提交git push origin hexo 推送到远程分支此时刷新github，就可以看到hexo分支将.git文件拷贝到MyBlog文件下，注意以后写博客等操作都在hexo分支下写博客的推送依旧利用hexo g -d进行推送运行之后记得同步到分支git add . &amp; git commit -m “blog env” &amp; git push origin hexo进行环境的同步 另一台电脑安装nodejs和hexo(即上文的前期准备) 下载hexo分支git clone -b hexo git@github.com: yourusername/yourusername.github.io.git 初始化hexo目录$ cd yourusername.github.io$ npm install hexo$ npm install$ npm install hexo-deployer-git 同步git pull origin hexo 写博客hexo new “文章” 清空并生成并发表hexo clean &amp;&amp; hexo g -d 同步环境git add . &amp;&amp; git commit -m “xxx” &amp;&amp; git push origin hexo 注: 如果返回上一台电脑就可从第3步开始，首先拉去最新的信息，在写文章 一些有用的插件npm install hexo-generator-searchdb –save (搜索插件)npm install hexo-asset-image –save (图片插入) 参考https://godweiyang.com/2018/04/13/hexo-blog/https://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/https://www.jianshu.com/p/fceaf373d797http://mcbill.cn/2018/06/22/Hexo%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2/]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
</search>
